<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Multi-tier Caching for Block Device Operations | Storage Administration Guide | SUSE Linux Enterprise Server 12 SP3</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /><link rel="stylesheet" type="text/css" href="static/css/style.css" /><link rel="stylesheet" type="text/css" href="static/css/highlight.css" /><meta name="generator" content="DAPS 2.4.0 using SUSE XSL Stylesheets 2.0.8 (based on DocBook XSL Stylesheets 1.78.1) - chunked" /><meta name="product-name" content="SUSE Linux Enterprise Server" /><meta name="product-number" content="12 SP3" /><meta name="book-title" content="Storage Administration Guide" /><meta name="chapter-title" content="Chapter 4. Multi-tier Caching for Block Device Operations" /><meta name="tracker-url" content="https://bugzilla.suse.com/enter_bug.cgi" /><meta name="tracker-type" content="bsc" /><meta name="tracker-bsc-assignee" content="fs@suse.com" /><meta name="tracker-bsc-component" content="Documentation" /><meta name="tracker-bsc-product" content="SUSE Linux Enterprise Server 12 SP3" /><link rel="home" href="index.html" title="SUSE Linux Enterprise Server Documentation" /><link rel="up" href="part.filesystems.html" title="Part I. File Systems and Mounting" /><link rel="prev" href="cha.uuid.html" title="Chapter 3. Using UUIDs to Mount Devices" /><link rel="next" href="part.lvm.html" title="Part II. Logical Volumes (LVM)" /><script type="text/javascript">

var protocol = window.location.protocol.toLowerCase();
if ( protocol != 'file:' ) {
  var agent = navigator.userAgent.toLowerCase();
  var wanted = ( protocol == 'https:') ? 'https' : 'http';
  var file = 'fonts.css';
  document.write('<link rel="stylesheet" type="text/css" href="' + wanted + '://static.opensuse.org/fonts/'+ file +'"></link>');
}
else {
   document.write('<link rel="stylesheet" type="text/css" href="static/css/fonts-onlylocal.css"></link>');
}

</script><noscript><link rel="stylesheet" type="text/css" href="http://static.opensuse.org/fonts/fonts.css" /></noscript><script src="static/js/jquery-1.10.2.min.js" type="text/javascript"></script><script src="static/js/script.js" type="text/javascript"></script><script src="static/js/highlight.min.js" type="text/javascript"></script><script>

$(document).ready(function() {
  $('.verbatim-wrap.highlight').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
hljs.configure({
  useBR: false
});

</script></head><body class="draft offline js-off"><div id="_outer-wrap"><div id="_white-bg"><div id="_header"><div id="_logo"><img src="static/images/logo.png" alt="Logo" /></div><div class="crumbs"><a class="book-link" href="index.html" title="SUSE Linux Enterprise Server Documentation"><span class="book-icon">SUSE Linux Enterprise Server Documentation</span></a><span> › </span><a class="crumb" href="stor_admin.html">Storage Administration Guide</a><span> › </span><a class="crumb" href="part.filesystems.html">File Systems and Mounting</a><span> › </span><a class="crumb" href="cha.multitiercache.html">Multi-tier Caching for Block Device Operations</a></div><div class="clearme"></div></div></div><div id="_toolbar-wrap"><div id="_toolbar"><div id="_toc-area" class="inactive"><a id="_toc-area-button" class="tool" title="Contents" accesskey="c" href="index.html"><span class="tool-spacer"><span class="toc-icon">Contents</span><span class="clearme"></span></span><span class="tool-label">Contents</span></a><div class="active-contents bubble-corner"></div><div class="active-contents bubble"><div class="bubble-container"><h6>Storage Administration Guide</h6><div id="_bubble-toc"><ol><li class="inactive"><a href="storage.preface.html"><span class="number"> </span><span class="name">About This Guide</span></a></li><li class="inactive"><a href="part.filesystems.html"><span class="number">I </span><span class="name">File Systems and Mounting</span></a><ol><li class="inactive"><a href="cha.filesystems.html"><span class="number">1 </span><span class="name">Overview of File Systems in Linux</span></a></li><li class="inactive"><a href="cha.resize_fs.html"><span class="number">2 </span><span class="name">Resizing File Systems</span></a></li><li class="inactive"><a href="cha.uuid.html"><span class="number">3 </span><span class="name">Using UUIDs to Mount Devices</span></a></li><li class="inactive"><a href="cha.multitiercache.html"><span class="number">4 </span><span class="name">Multi-tier Caching for Block Device Operations</span></a></li></ol></li><li class="inactive"><a href="part.lvm.html"><span class="number">II </span><span class="name">Logical Volumes (LVM)</span></a><ol><li class="inactive"><a href="cha.lvm.html"><span class="number">5 </span><span class="name">LVM Configuration</span></a></li><li class="inactive"><a href="cha.lvm_snapshots.html"><span class="number">6 </span><span class="name">LVM Volume Snapshots</span></a></li></ol></li><li class="inactive"><a href="part.software_raid.html"><span class="number">III </span><span class="name">Software RAID</span></a><ol><li class="inactive"><a href="cha.raid.html"><span class="number">7 </span><span class="name">Software RAID Configuration</span></a></li><li class="inactive"><a href="cha.raidroot.html"><span class="number">8 </span><span class="name">Configuring Software RAID for the Root Partition</span></a></li><li class="inactive"><a href="cha.raid10.html"><span class="number">9 </span><span class="name">Creating Software RAID 10 Devices</span></a></li><li class="inactive"><a href="cha.raid_degraded.html"><span class="number">10 </span><span class="name">Creating a Degraded RAID Array</span></a></li><li class="inactive"><a href="cha.raid_resize.html"><span class="number">11 </span><span class="name">Resizing Software RAID Arrays with mdadm</span></a></li><li class="inactive"><a href="cha.raid_leds.html"><span class="number">12 </span><span class="name">Storage Enclosure LED Utilities for MD Software RAIDs</span></a></li></ol></li><li class="inactive"><a href="part.net_storage.html"><span class="number">IV </span><span class="name">Network Storage</span></a><ol><li class="inactive"><a href="cha.isns.html"><span class="number">13 </span><span class="name">iSNS for Linux</span></a></li><li class="inactive"><a href="cha.iscsi.html"><span class="number">14 </span><span class="name">Mass Storage over IP Networks: iSCSI</span></a></li><li class="inactive"><a href="cha.fcoe.html"><span class="number">15 </span><span class="name">Fibre Channel Storage over Ethernet Networks: FCoE</span></a></li><li class="inactive"><a href="cha.nvmeof.html"><span class="number">16 </span><span class="name">NVMe over Fabric</span></a></li><li class="inactive"><a href="cha.multipath.html"><span class="number">17 </span><span class="name">Managing Multipath I/O for Devices</span></a></li><li class="inactive"><a href="cha.nfs4_acls.html"><span class="number">18 </span><span class="name">Managing Access Control Lists over NFSv4</span></a></li></ol></li><li class="inactive"><a href="app.storage.docupdates.html"><span class="number">A </span><span class="name">Documentation Updates</span></a></li><li class="inactive"><a href="bk08apb.html"><span class="number">B </span><span class="name">GNU Licenses</span></a></li></ol></div><div class="clearme"></div></div></div></div><div id="_nav-area" class="inactive"><div class="tool"><span class="nav-inner"><span class="tool-label">Navigation</span><a accesskey="p" class="tool-spacer" title="Chapter 3. Using UUIDs to Mount Devices" href="cha.uuid.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Part II. Logical Volumes (LVM)" href="part.lvm.html"><span class="next-icon">→</span></a></span></div></div></div></div><div id="_fixed-header-wrap" class="inactive"><div id="_fixed-header"><div class="crumbs"><a class="book-link" href="index.html" title="SUSE Linux Enterprise Server Documentation"><span class="book-icon">SUSE Linux Enterprise Server Documentation</span></a><span> › </span><a class="crumb" href="stor_admin.html">Storage Administration Guide</a><span> › </span><a class="crumb" href="part.filesystems.html">File Systems and Mounting</a><span> › </span><a class="crumb" href="cha.multitiercache.html">Multi-tier Caching for Block Device Operations</a></div><div class="buttons"><a class="top-button button" href="#">Top</a><div class="button"><a accesskey="p" class="tool-spacer" title="Chapter 3. Using UUIDs to Mount Devices" href="cha.uuid.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Part II. Logical Volumes (LVM)" href="part.lvm.html"><span class="next-icon">→</span></a></div><div class="clearme"></div></div><div class="clearme"></div></div></div><div id="_content" class="draft "><div class="documentation"><div xml:lang="en" class="chapter " id="cha.multitiercache" lang="en"><div class="titlepage"><div><div class="version-info">Applies to  <span class="productname"><span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span></span> <span class="productnumber"><span class="productnumber"><span class="phrase">12 SP3</span></span></span></div><div><h2 class="title"><span class="number">4 </span><span class="name">Multi-tier Caching for Block Device Operations</span> </h2><div class="doc-status"><ul><li><span class="ds-label">Filename: </span>storage_multitier-caching.xml</li><li><span class="ds-label">ID: </span>cha.multitiercache</li></ul></div></div></div></div><div class="line"><div class="toc"><dl><dt><span class="sect1"><a href="cha.multitiercache.html#sec.multitiercache.terminology"><span class="number">4.1 </span><span class="name">General Terminology</span></a></span></dt><dt><span class="sect1"><a href="cha.multitiercache.html#sec.multitiercache.caching_modes"><span class="number">4.2 </span><span class="name">Caching Modes</span></a></span></dt><dt><span class="sect1"><a href="cha.multitiercache.html#sec.multitiercache.bcache"><span class="number">4.3 </span><span class="name"><code class="systemitem">bcache</code></span></a></span></dt><dt><span class="sect1"><a href="cha.multitiercache.html#sec.multitiercache.lvmcache"><span class="number">4.4 </span><span class="name"><code class="systemitem">lvmcache</code></span></a></span></dt></dl></div></div><p>
  A multi-tier cache is a replicated/distributed cache that consists of at
  least two tiers: one is represented by slower but cheaper rotational block
  devices (hard disks), while the other is more expensive but performs faster
  data operations (for example SSD flash disks).
 </p><p>
  SUSE Linux Enterprise Server implements two different solutions for caching between flash and
  rotational devices: <code class="systemitem">bcache</code> and <code class="systemitem">lvmcache</code>.
 </p><div class="sect1 " id="sec.multitiercache.terminology"><div class="titlepage"><div><div><h2 class="title" id="sec.multitiercache.terminology"><span class="number">4.1 </span><span class="name">General Terminology</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.terminology">#</a></h2></div></div></div><p>
   This section explains several terms often used when describing cache related
   features:
  </p><div class="variablelist "><dl class="variablelist"><dt id="idm139973609404256"><span class="term ">Migration</span></dt><dd><p>
      Movement of the primary copy of a logical block from one device to the
      other.
     </p></dd><dt id="idm139973609402384"><span class="term ">Promotion</span></dt><dd><p>
      Migration from the slow device to the fast device.
     </p></dd><dt id="idm139973609400544"><span class="term ">Demotion</span></dt><dd><p>
      Migration from the fast device to the slow device.
     </p></dd><dt id="idm139973609398704"><span class="term ">Origin device</span></dt><dd><p>
      The big and slower block device. It always contains a copy of the logical
      block, which may be out of date or kept in synchronization with the copy
      on the cache device (depending on policy).
     </p></dd><dt id="idm139973609396720"><span class="term ">Cache device</span></dt><dd><p>
      The small and faster block device.
     </p></dd><dt id="idm139973609394896"><span class="term ">Metadata device</span></dt><dd><p>
      A small device that records which blocks are in the cache, which are
      dirty, and extra hints for use by the policy object. This information
      could be put on the cache device as well, but having it separate allows
      the volume manager to configure it differently, for example as a mirror
      for extra robustness. The metadata device may only be used by a single
      cache device.
     </p></dd><dt id="idm139973609392704"><span class="term ">Dirty block</span></dt><dd><p>
      If some process writes to a block of data which is placed in the cache,
      the cached block is marked as <span class="emphasis"><em>dirty</em></span> because it was
      overwritten in the cache and needs to be written back to the original
      device.
     </p></dd><dt id="idm139973609390272"><span class="term ">Cache miss</span></dt><dd><p>
      A request for I/O operations is pointed to the cached device's cache
      first. If it cannot find the requested values, it looks in the device
      itself, which is slow. This is called a <span class="emphasis"><em>cache miss</em></span>.
     </p></dd><dt id="idm139973609387856"><span class="term ">Cache hit</span></dt><dd><p>
      When a requested value is found in the cached device's cache, it is
      served fast. This is called a <span class="emphasis"><em>cache hit</em></span>.
     </p></dd><dt id="idm139973609385520"><span class="term ">Cold cache</span></dt><dd><p>
      Cache that holds no values (is empty) and causes <span class="emphasis"><em>cache
      misses</em></span>. As the cached block device operations progress, it
      gets filled with data and becomes <span class="emphasis"><em>warm</em></span>.
     </p></dd><dt id="idm139973609382704"><span class="term ">Warm cache</span></dt><dd><p>
      Cache that already holds some values and is likely to result in
      <span class="emphasis"><em>cache hits</em></span>.
     </p></dd></dl></div></div><div class="sect1 " id="sec.multitiercache.caching_modes"><div class="titlepage"><div><div><h2 class="title" id="sec.multitiercache.caching_modes"><span class="number">4.2 </span><span class="name">Caching Modes</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.caching_modes">#</a></h2></div></div></div><p>
   Following are the basic caching modes that multi-tier caches use:
   <span class="emphasis"><em>write-back</em></span>, <span class="emphasis"><em>write-through</em></span>,
   <span class="emphasis"><em>write-around</em></span> and <span class="emphasis"><em>pass-through</em></span>.
  </p><div class="variablelist "><dl class="variablelist"><dt id="idm139973609376288"><span class="term ">write-back</span></dt><dd><p>
      Data written to a block that is cached go to the cache only, and the
      block is marked dirty. This is the default caching mode.
     </p></dd><dt id="idm139973609374368"><span class="term ">write-through</span></dt><dd><p>
      Writing to a cached block will not complete until it has hit both the
      origin and cache devices. Clean blocks remain clean with
      <span class="emphasis"><em>write-through</em></span> cache.
     </p></dd><dt id="idm139973609372000"><span class="term ">write-around</span></dt><dd><p>
      A similar technique to write-through cache, but write I/O is written
      directly to a permanent storage, bypassing the cache. This can prevent
      the cache being flooded with write I/O that will not subsequently be
      re-read, but the disadvantage is that a read request for recently written
      data will create a 'cache miss' and needs to be read from slower bulk
      storage and experience higher latency.
     </p></dd><dt id="idm139973609369792"><span class="term ">pass-through</span></dt><dd><p>
      To enable the <span class="emphasis"><em>pass-through</em></span> mode, the cache needs to
      be clean. Reading is served from the origin device bypassing the cache.
      Writing is forwarded to the origin device and 'invalidates' the cache
      block. <span class="emphasis"><em>Pass-through</em></span> allows a cache device activation
      without having to care about data coherency, which is maintained. The
      cache will gradually become cold as writing takes place. If you can
      verify the coherency of the cache later, or establish it by using the
      <code class="literal">invalidate_cblocks</code> message, you can switch the cache
      device to <span class="emphasis"><em>write-through</em></span> or
      <span class="emphasis"><em>write-back</em></span> mode while it is still warm. Otherwise,
      you can discard the cache contents before switching to the desired
      caching mode.
     </p></dd></dl></div></div><div class="sect1 " id="sec.multitiercache.bcache"><div class="titlepage"><div><div><h2 class="title" id="sec.multitiercache.bcache"><span class="number">4.3 </span><span class="name"><code class="systemitem">bcache</code></span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.bcache">#</a></h2></div></div></div><p>
   <code class="systemitem">bcache</code> is a Linux kernel block layer cache. It allows one or more fast
   disk drives (such as SSDs) to act as a cache for one or more slower hard
   disks. <code class="systemitem">bcache</code> supports write-through and write-back, and is independent of
   the file system used. By default it caches random reads and writes only,
   which SSDs excel at. It is suitable for desktops, servers, and high end
   storage arrays as well.
  </p><div class="sect2 " id="sec.multitiercache.bcache.features"><div class="titlepage"><div><div><h3 class="title" id="sec.multitiercache.bcache.features"><span class="number">4.3.1 </span><span class="name">Main Features</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.bcache.features">#</a></h3></div></div></div><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
      A single cache device can be used to cache an arbitrary number of backing
      devices. Backing devices can be attached and detached at runtime, while
      mounted and in use.
     </p></li><li class="listitem "><p>
      Recovers from unclean shutdowns—writes are not completed until the
      cache is consistent with regard to the backing device.
     </p></li><li class="listitem "><p>
      Throttles traffic to the SSD if it becomes congested.
     </p></li><li class="listitem "><p>
      Highly efficient write-back implementation. Dirty data is always written
      out in sorted order.
     </p></li><li class="listitem "><p>
      Stable and reliable—in production use.
     </p></li></ul></div></div><div class="sect2 " id="sec.multitiercache.bcache.setting_bcache_device"><div class="titlepage"><div><div><h3 class="title" id="sec.multitiercache.bcache.setting_bcache_device"><span class="number">4.3.2 </span><span class="name">Setting Up a <code class="systemitem">bcache</code> Device</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.bcache.setting_bcache_device">#</a></h3></div></div></div><p>
    This section describes steps to set up and manage a <code class="systemitem">bcache</code> device.
   </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      Install the <code class="systemitem">bcache-tools</code> package:
     </p><div class="verbatim-wrap"><pre class="screen">sudo zypper in bcache-tools</pre></div></li><li class="step "><p>
      Create a backing device (typically a mechanical drive). The backing
      device can be a whole device, a partition, or any other standard block
      device.
     </p><div class="verbatim-wrap"><pre class="screen">sudo make-bcache -B /dev/sdb</pre></div></li><li class="step "><p>
      Create a cache device (typically an SSD disk).
     </p><div class="verbatim-wrap"><pre class="screen">sudo make-bcache -C /dev/sdc</pre></div><p>
      In this example, the default block and bucket sizes of 512 B and 128 KB
      are used. The block size should match the backing device's sector size
      which will usually be either 512 or 4k. The bucket size should match the
      erase block size of the caching device with the intention of reducing
      write amplification. For example, using a hard disk with 4k sectors and
      an SSD with an erase block size of 2 MB this command would look as
      follows:
     </p><div class="verbatim-wrap"><pre class="screen">sudo make-bcache --block 4k --bucket 2M -C /dev/sdc</pre></div><div id="idm139973609344864" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Multi-Device Support</h6><p>
       <code class="command">make-bcache</code> can prepare and register multiple backing
       devices and a cache device at the same time. In this case you do not
       need to manually attach the cache device to the backing device
       afterward:
      </p><div class="verbatim-wrap"><pre class="screen">sudo make-bcache -B /dev/sda /dev/sdb -C /dev/sdc</pre></div></div></li><li class="step "><p>
      <code class="systemitem">bcache</code> devices show up as
     </p><div class="verbatim-wrap"><pre class="screen">/dev/bcache<em class="replaceable ">N</em></pre></div><p>
      and as
     </p><div class="verbatim-wrap"><pre class="screen">/dev/bcache/by-uuid/<em class="replaceable ">UUID</em>
/dev/bcache/by-label/<em class="replaceable ">LABEL</em></pre></div><p>
      You can normally format and mount <code class="systemitem">bcache</code> devices as usual:
     </p><div class="verbatim-wrap"><pre class="screen">mkfs.ext4 /dev/bcache0
mount /dev/bcache0 /mnt</pre></div><p>
      You can control <code class="systemitem">bcache</code> devices through <code class="systemitem">sysfs</code>
      at
      <code class="filename">/sys/block/bcache<em class="replaceable ">N</em>/bcache</code>.
     </p></li><li class="step "><p>
      After both the cache and backing devices are registered, you need to
      attach the backing device to the related cache set to enable caching:
     </p><div class="verbatim-wrap"><pre class="screen">echo <em class="replaceable ">CACHE_SET_UUID</em> &gt; /sys/block/bcache0/bcache/attach</pre></div><p>
      where <em class="replaceable ">CACHE_SET_UUID</em> is found in
      <code class="filename">/sys/fs/bcache</code>.
     </p></li><li class="step "><p>
      By default <code class="systemitem">bcache</code> uses a pass-through caching mode. To change it to for
      example write-back, run
     </p><div class="verbatim-wrap"><pre class="screen">echo writeback &gt; /sys/block/bcache0/bcache/cache_mode</pre></div></li></ol></div></div></div><div class="sect2 " id="sec.multitiercache.bcache.sysfs"><div class="titlepage"><div><div><h3 class="title" id="sec.multitiercache.bcache.sysfs"><span class="number">4.3.3 </span><span class="name"><code class="systemitem">bcache</code> Configuration Using <code class="systemitem">sysfs</code></span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.bcache.sysfs">#</a></h3></div></div></div><p>
    <code class="systemitem">bcache</code> devices use the <code class="systemitem">sysfs</code> interface to store
    their runtime configuration values. This way you can change <code class="systemitem">bcache</code>
    backing and cache disks' behavior or see their usage statistics.
   </p><p>
    For the complete list of <code class="systemitem">bcache</code> <code class="systemitem">sysfs</code>
    parameters, see the contents of the
    <code class="filename">/usr/src/linux/Documentation/bcache.txt</code> file, mainly
    the <code class="literal">SYSFS - BACKING DEVICE</code>, <code class="literal">SYSFS - BACKING
    DEVICE STATS</code>, and <code class="literal">SYSFS - CACHE DEVICE</code>
    sections.
   </p></div></div><div class="sect1 " id="sec.multitiercache.lvmcache"><div class="titlepage"><div><div><h2 class="title" id="sec.multitiercache.lvmcache"><span class="number">4.4 </span><span class="name"><code class="systemitem">lvmcache</code></span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.lvmcache">#</a></h2></div></div></div><p>
   <code class="systemitem">lvmcache</code> is a caching mechanism consisting of logical volumes (LVs). It
   uses the <code class="literal">dm-cache</code> kernel driver and supports
   write-through (default) and write-back caching modes. <code class="systemitem">lvmcache</code> improves
   performance of a large and slow LV by dynamically migrating some of its data
   to a faster and smaller LV. For more information on LVM, see
   <a class="xref" href="part.lvm.html" title="Part II. Logical Volumes (LVM)">Part II, “Logical Volumes (LVM)”</a>.
  </p><p>
   LVM refers to the small, fast LV as a <span class="emphasis"><em>cache pool LV</em></span>.
   The large, slow LV is called the <span class="emphasis"><em>origin LV</em></span>. Because of
   requirements from dm-cache, LVM further splits the cache pool LV into two
   devices: the <span class="emphasis"><em>cache data LV</em></span> and <span class="emphasis"><em>cache
   metadata LV</em></span>. The cache data LV is where copies of data blocks
   are kept from the origin LV to increase speed. The cache metadata LV holds
   the accounting information that specifies where data blocks are stored.
  </p><div class="sect2 " id="sec.multitiercache.lvmcache.configure"><div class="titlepage"><div><div><h3 class="title" id="sec.multitiercache.lvmcache.configure"><span class="number">4.4.1 </span><span class="name">Configuring <code class="systemitem">lvmcache</code></span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.lvmcache.configure">#</a></h3></div></div></div><p>
    This section describes steps to create and configure LVM based caching.
   </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      <span class="emphasis"><em>Create the origin LV.</em></span> Create a new LV or use an
      existing LV to become the origin LV:
     </p><div class="verbatim-wrap"><pre class="screen">lvcreate -n <em class="replaceable ">ORIGIN_LV</em> -L 100G vg <em class="replaceable ">/dev/SLOW_DEV</em></pre></div></li><li class="step "><p>
      <span class="emphasis"><em>Create the cache data LV.</em></span> This LV will hold data
      blocks from the origin LV. The size of this LV is the size of the cache
      and will be reported as the size of the cache pool LV.
     </p><div class="verbatim-wrap"><pre class="screen">lvcreate -n <em class="replaceable ">CACHE_DATA_LV</em> -L 10G vg <em class="replaceable ">/dev/FAST</em></pre></div></li><li class="step "><p>
      <span class="emphasis"><em>Create the cache metadata LV.</em></span> This LV will hold
      cache pool metadata. The size of this LV should be approximately 1000
      times smaller than the cache data LV, with a minimum size of 8MB.
     </p><div class="verbatim-wrap"><pre class="screen">lvcreate -n <em class="replaceable ">CACHE_METADATA_LV</em> -L 12M vg <em class="replaceable ">/dev/FAST</em></pre></div><p>
      List the volumes you have created so far:
     </p><div class="verbatim-wrap"><pre class="screen">lvs -a vg
LV                VG   Attr        LSize   Pool Origin
cache_data_lv     vg   -wi-a-----  10.00g
cache_metadata_lv vg   -wi-a-----  12.00m
origin_lv         vg   -wi-a----- 100.00g</pre></div></li><li class="step "><p>
      <span class="emphasis"><em>Create a cache pool LV.</em></span> Combine the data and
      metadata LVs into a cache pool LV. You can set the cache pool LV's
      behavior at the same time.
     </p><p>
      <em class="replaceable ">CACHE_POOL_LV</em> takes the name of
      <em class="replaceable ">CACHE_DATA_LV</em>.
     </p><p>
      <em class="replaceable ">CACHE_DATA_LV</em> is renamed to
      <em class="replaceable ">CACHE_DATA_LV</em>_cdata and becomes hidden.
     </p><p>
      <em class="replaceable ">CACHE_META_LV</em> is renamed to
      <em class="replaceable ">CACHE_DATA_LV</em>_cmeta and becomes hidden.
     </p><div class="verbatim-wrap"><pre class="screen">lvconvert --type cache-pool \
 --poolmetadata vg/cache_metadata_lv vg/cache_data_lv</pre></div><div class="verbatim-wrap"><pre class="screen">lvs -a vg
LV                     VG   Attr       LSize   Pool Origin
cache_data_lv          vg   Cwi---C---  10.00g
[cache_data_lv_cdata]  vg   Cwi-------  10.00g
[cache_data_lv_cmeta]  vg   ewi-------  12.00m
origin_lv              vg   -wi-a----- 100.00g</pre></div></li><li class="step "><p>
      <span class="emphasis"><em>Create a cache LV.</em></span> Create a cache LV by linking the
      cache pool LV to the origin LV.
     </p><p>
      The user accessible cache LV takes the name of the origin LV, while the
      origin LV becomes a hidden LV renamed to
      <em class="replaceable ">ORIGIN_LV</em>_corig.
     </p><p>
      CacheLV takes the name of <em class="replaceable ">ORIGIN_LV</em>.
     </p><p>
      <em class="replaceable ">ORIGIN_LV</em> is renamed to
      <em class="replaceable ">ORIGIN_LV</em>_corig and becomes hidden.
     </p><div class="verbatim-wrap"><pre class="screen">lvconvert --type cache --cachepool vg/cache_data_lv vg/origin_lv</pre></div><div class="verbatim-wrap"><pre class="screen">lvs -a vg
LV              VG   Attr       LSize   Pool   Origin
cache_data_lv          vg   Cwi---C---  10.00g
[cache_data_lv_cdata]  vg   Cwi-ao----  10.00g
[cache_data_lv_cmeta]  vg   ewi-ao----  12.00m
origin_lv              vg   Cwi-a-C--- 100.00g cache_data_lv [origin_lv_corig]
[origin_lv_corig]      vg   -wi-ao---- 100.00g</pre></div></li></ol></div></div></div><div class="sect2 " id="sec.multitiercache.lvmcache.remove"><div class="titlepage"><div><div><h3 class="title" id="sec.multitiercache.lvmcache.remove"><span class="number">4.4.2 </span><span class="name">Removing a Cache Pool</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.lvmcache.remove">#</a></h3></div></div></div><p>
    There are several ways to turn off the LV cache.
   </p><div class="sect3 " id="sec.multitiercache.lvmcache.remove.detach"><div class="titlepage"><div><div><h4 class="title" id="sec.multitiercache.lvmcache.remove.detach"><span class="number">4.4.2.1 </span><span class="name">Detach a Cache Pool LV from a Cache LV</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.lvmcache.remove.detach">#</a></h4></div></div></div><p>
     You can disconnect a cache pool LV from a cache LV, leaving an unused
     cache pool LV and an uncached origin LV. Data are written back from the
     cache pool to the origin LV when necessary.
    </p><div class="verbatim-wrap"><pre class="screen">lvconvert --splitcache vg/origin_lv</pre></div></div><div class="sect3 " id="sec.multitiercache.lvmcache.remove.wo_origin"><div class="titlepage"><div><div><h4 class="title" id="sec.multitiercache.lvmcache.remove.wo_origin"><span class="number">4.4.2.2 </span><span class="name">Removing a Cache Pool LV without Removing its Origin LV</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.lvmcache.remove.wo_origin">#</a></h4></div></div></div><p>
     This writes back data from the cache pool to the origin LV when necessary,
     then removes the cache pool LV, leaving the uncached origin LV.
    </p><div class="verbatim-wrap"><pre class="screen">lvremove vg/cache_data_lv</pre></div><p>
     An alternative command that also disconnects the cache pool from the cache
     LV, and deletes the cache pool:
    </p><div class="verbatim-wrap"><pre class="screen">lvconvert --uncache vg/origin_lv</pre></div></div><div class="sect3 " id="sec.multitiercache.lvmcache.remove.both"><div class="titlepage"><div><div><h4 class="title" id="sec.multitiercache.lvmcache.remove.both"><span class="number">4.4.2.3 </span><span class="name">Removing Both the Origin LV and the Cache Pool LV</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.lvmcache.remove.both">#</a></h4></div></div></div><p>
     Removing a cache LV removes both the origin LV and the linked cache pool
     LV.
    </p><div class="verbatim-wrap"><pre class="screen">lvremove vg/origin_lv</pre></div></div><div class="sect3 " id="sec.multitiercache.lvmcache.remove.info"><div class="titlepage"><div><div><h4 class="title" id="sec.multitiercache.lvmcache.remove.info"><span class="number">4.4.2.4 </span><span class="name">For More Information</span> <a title="Permalink" class="permalink" href="cha.multitiercache.html#sec.multitiercache.lvmcache.remove.info">#</a></h4></div></div></div><p>
     You can find more <code class="systemitem">lvmcache</code> related topics, such as supported cache
     modes, redundant sub-logical volumes, cache policy, or converting existing
     LVs to cache types, in the <code class="systemitem">lvmcache</code> manual page (<code class="command">man 7
     lvmcache</code>).
    </p></div></div></div></div></div><div class="page-bottom"><div id="_bottom-navigation"><a class="nav-link" href="part.lvm.html"><span class="next-icon">→</span><span class="nav-label"><span class="number">Part II </span>Logical Volumes (LVM)</span></a><a class="nav-link" href="cha.uuid.html"><span class="prev-icon">←</span><span class="nav-label"><span class="number">Chapter 3 </span>Using UUIDs to Mount Devices</span></a></div><div id="_share-print"><div class="online-contents share"><strong>Share this page: </strong><span class="share-buttons"><span id="_share-fb" class="bottom-button">Facebook</span><span class="spacer"> • </span><span id="_share-gp" class="bottom-button">Google+</span><span class="spacer"> • </span><span id="_share-tw" class="bottom-button">Twitter</span><span class="spacer"> • </span><span id="_share-mail" class="bottom-button">E-Mail</span></span></div><div class="print"><span id="_print-button" class="bottom-button">Print this page</span></div><div class="clearme"></div></div></div></div><div id="_inward"></div></div><div id="_footer-wrap"><div id="_footer"><p>©
        2018 
        SUSE</p><ul><li><a href="http://www.suse.com/company/careers/" target="_top">Careers</a></li><li><a href="http://www.suse.com/company/legal/" target="_top">Legal</a></li><li><a href="http://www.suse.com/company/" target="_top">About</a></li><li><a href="http://www.suse.com/ContactsOffices/contacts_offices.jsp" target="_top">Contact Us</a></li></ul></div></div></body></html>