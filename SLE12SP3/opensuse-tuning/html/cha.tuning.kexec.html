<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Kexec and Kdump | System Analysis and Tuning Guide | openSUSE Leap 42.3</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /><link rel="stylesheet" type="text/css" href="static/css/style.css" /><link rel="stylesheet" type="text/css" href="static/css/highlight.css" /><link rel="stylesheet" type="text/css" href="static/css/brand.css" /><meta name="generator" content="DAPS 2.4.0 using openSUSE XSL Stylesheets 2.0.8 (based on DocBook XSL Stylesheets 1.78.1) - chunked" /><meta name="product-name" content="openSUSE Leap" /><meta name="product-number" content="42.3" /><meta name="book-title" content="System Analysis and Tuning Guide" /><meta name="chapter-title" content="Chapter 17. Kexec and Kdump" /><meta name="tracker-url" content="https://bugzilla.opensuse.org/enter_bug.cgi" /><meta name="tracker-type" content="bsc" /><meta name="tracker-bsc-assignee" content="fs@suse.com" /><meta name="tracker-bsc-component" content="Documentation" /><meta name="tracker-bsc-product" content="openSUSE Distribution" /><meta name="tracker-bsc-version" content="Leap 42.2" /><link rel="home" href="index.html" title="openSUSE Leap Documentation" /><link rel="up" href="part.tuning.dumps.html" title="Part VI. Handling System Dumps" /><link rel="prev" href="cha.tuning.tracing.html" title="Chapter 16. Tracing Tools" /><link rel="next" href="part.tuning.ptp.html" title="Part VII. Synchronized Clocks with Precision Time Protocol" /><script type="text/javascript">

var protocol = window.location.protocol.toLowerCase();
if ( protocol != 'file:' ) {
  var agent = navigator.userAgent.toLowerCase();
  var wanted = ( protocol == 'https:') ? 'https' : 'http';
  var file = 'fonts.css';
  document.write('<link rel="stylesheet" type="text/css" href="' + wanted + '://static.opensuse.org/fonts/'+ file +'"></link>');
}
else {
   document.write('<link rel="stylesheet" type="text/css" href="static/css/fonts-onlylocal.css"></link>');
}

</script><noscript><link rel="stylesheet" type="text/css" href="http://static.opensuse.org/fonts/fonts.css" /></noscript><script src="static/js/jquery-1.10.2.min.js" type="text/javascript"></script><script src="static/js/script.js" type="text/javascript"></script><script src="static/js/highlight.min.js" type="text/javascript"></script><script>

$(document).ready(function() {
  $('.verbatim-wrap.highlight').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
hljs.configure({
  useBR: false
});

</script></head><body class="draft offline js-off"><div id="_outer-wrap"><div id="_white-bg"><div id="_header"><div id="_logo"><img src="static/images/logo.png" alt="Logo" /></div><div class="crumbs"><a class="book-link" href="index.html" title="openSUSE Leap Documentation"><span class="book-icon">openSUSE Leap Documentation</span></a><span> › </span><a class="crumb" href="book.sle.tuning.html">System Analysis and Tuning Guide</a><span> › </span><a class="crumb" href="part.tuning.dumps.html">Handling System Dumps</a><span> › </span><a class="crumb" href="cha.tuning.kexec.html">Kexec and Kdump</a></div><div class="clearme"></div></div></div><div id="_toolbar-wrap"><div id="_toolbar"><div id="_toc-area" class="inactive"><a id="_toc-area-button" class="tool" title="Contents" accesskey="c" href="index.html"><span class="tool-spacer"><span class="toc-icon">Contents</span><span class="clearme"></span></span><span class="tool-label">Contents</span></a><div class="active-contents bubble-corner"></div><div class="active-contents bubble"><div class="bubble-container"><h6>System Analysis and Tuning Guide</h6><div id="_bubble-toc"><ol><li class="inactive"><a href="preface.tuning.html"><span class="number"> </span><span class="name">About This Guide</span></a></li><li class="inactive"><a href="part.tuning.basics.html"><span class="number">I </span><span class="name">Basics</span></a><ol><li class="inactive"><a href="cha.tuning.basics.html"><span class="number">1 </span><span class="name">General Notes on System Tuning</span></a></li></ol></li><li class="inactive"><a href="part.tuning.monitoring.html"><span class="number">II </span><span class="name">System Monitoring</span></a><ol><li class="inactive"><a href="cha.util.html"><span class="number">2 </span><span class="name">System Monitoring Utilities</span></a></li><li class="inactive"><a href="cha.tuning.logfiles.html"><span class="number">3 </span><span class="name">Analyzing and Managing System Log Files</span></a></li></ol></li><li class="inactive"><a href="part.tuning.kerneltrace.html"><span class="number">III </span><span class="name">Kernel Monitoring</span></a><ol><li class="inactive"><a href="cha.tuning.systemtap.html"><span class="number">4 </span><span class="name">SystemTap—Filtering and Analyzing System Data</span></a></li><li class="inactive"><a href="cha.tuning.kprobes.html"><span class="number">5 </span><span class="name">Kernel Probes</span></a></li><li class="inactive"><a href="cha.perf.html"><span class="number">6 </span><span class="name">Hardware-Based Performance Monitoring with Perf</span></a></li><li class="inactive"><a href="cha.tuning.oprofile.html"><span class="number">7 </span><span class="name">OProfile—System-Wide Profiler</span></a></li></ol></li><li class="inactive"><a href="part.tuning.resources.html"><span class="number">IV </span><span class="name">Resource Management</span></a><ol><li class="inactive"><a href="cha.tuning.resources.html"><span class="number">8 </span><span class="name">General System Resource Management</span></a></li><li class="inactive"><a href="cha.tuning.cgroups.html"><span class="number">9 </span><span class="name">Kernel Control Groups</span></a></li><li class="inactive"><a href="cha.tuning.numactl.html"><span class="number">10 </span><span class="name">Automatic Non-Uniform Memory Access (NUMA) Balancing</span></a></li><li class="inactive"><a href="cha.tuning.power.html"><span class="number">11 </span><span class="name">Power Management</span></a></li></ol></li><li class="inactive"><a href="part.tuning.kernel.html"><span class="number">V </span><span class="name">Kernel Tuning</span></a><ol><li class="inactive"><a href="cha.tuning.io.html"><span class="number">12 </span><span class="name">Tuning I/O Performance</span></a></li><li class="inactive"><a href="cha.tuning.taskscheduler.html"><span class="number">13 </span><span class="name">Tuning the Task Scheduler</span></a></li><li class="inactive"><a href="cha.tuning.memory.html"><span class="number">14 </span><span class="name">Tuning the Memory Management Subsystem</span></a></li><li class="inactive"><a href="cha.tuning.network.html"><span class="number">15 </span><span class="name">Tuning the Network</span></a></li></ol></li><li class="inactive"><a href="part.tuning.dumps.html"><span class="number">VI </span><span class="name">Handling System Dumps</span></a><ol><li class="inactive"><a href="cha.tuning.tracing.html"><span class="number">16 </span><span class="name">Tracing Tools</span></a></li><li class="inactive"><a href="cha.tuning.kexec.html"><span class="number">17 </span><span class="name">Kexec and Kdump</span></a></li></ol></li><li class="inactive"><a href="part.tuning.ptp.html"><span class="number">VII </span><span class="name">Synchronized Clocks with Precision Time Protocol</span></a><ol><li class="inactive"><a href="cha.tuning.ptp.html"><span class="number">18 </span><span class="name">Precision Time Protocol</span></a></li></ol></li><li class="inactive"><a href="bk05apa.html"><span class="number">A </span><span class="name">GNU Licenses</span></a></li></ol></div><div class="clearme"></div></div></div></div><div id="_nav-area" class="inactive"><div class="tool"><span class="nav-inner"><span class="tool-label">Navigation</span><a accesskey="p" class="tool-spacer" title="Chapter 16. Tracing Tools" href="cha.tuning.tracing.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Part VII. Synchronized Clocks with Precision Time Protocol" href="part.tuning.ptp.html"><span class="next-icon">→</span></a></span></div></div></div></div><div id="_fixed-header-wrap" class="inactive"><div id="_fixed-header"><div class="crumbs"><a class="book-link" href="index.html" title="openSUSE Leap Documentation"><span class="book-icon">openSUSE Leap Documentation</span></a><span> › </span><a class="crumb" href="book.sle.tuning.html">System Analysis and Tuning Guide</a><span> › </span><a class="crumb" href="part.tuning.dumps.html">Handling System Dumps</a><span> › </span><a class="crumb" href="cha.tuning.kexec.html">Kexec and Kdump</a></div><div class="buttons"><a class="top-button button" href="#">Top</a><div class="button"><a accesskey="p" class="tool-spacer" title="Chapter 16. Tracing Tools" href="cha.tuning.tracing.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Part VII. Synchronized Clocks with Precision Time Protocol" href="part.tuning.ptp.html"><span class="next-icon">→</span></a></div><div class="clearme"></div></div><div class="clearme"></div></div></div><div id="_content" class="draft "><div class="documentation"><div class="chapter " id="cha.tuning.kexec"><div class="titlepage"><div><div class="version-info">Applies to  <span class="productname"><span class="productname"><span class="phrase">openSUSE Leap</span></span></span> <span class="productnumber"><span class="productnumber"><span class="phrase">42.3</span></span></span></div><div><h2 class="title"><span class="number">17 </span><span class="name">Kexec and Kdump</span> </h2><div class="doc-status"><ul><li><span class="ds-label">Filename: </span>tuning_kexec.xml</li><li><span class="ds-label">ID: </span>cha.tuning.kexec</li></ul></div></div></div></div><div class="line"><div class="toc"><dl><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kexec.intro"><span class="number">17.1 </span><span class="name">Introduction</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kexec.pkgs"><span class="number">17.2 </span><span class="name">Required Packages</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kexec.internals"><span class="number">17.3 </span><span class="name">Kexec Internals</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#sec.tuning.kexec.crashkernel"><span class="number">17.4 </span><span class="name">Calculating <code class="option">crashkernel</code> Allocation Size</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kexec.basic_usage"><span class="number">17.5 </span><span class="name">Basic Kexec Usage</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kexec.config"><span class="number">17.6 </span><span class="name">How to Configure Kexec for Routine Reboots</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kdump.basic"><span class="number">17.7 </span><span class="name">Basic Kdump Configuration</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kdump.analyze"><span class="number">17.8 </span><span class="name">Analyzing the Crash Dump</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kdump.advanced"><span class="number">17.9 </span><span class="name">Advanced Kdump Configuration</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.kexec.html#cha.tuning.kdump.moreinfo"><span class="number">17.10 </span><span class="name">For More Information</span></a></span></dt></dl></div></div><p>
  Kexec is a tool to boot to another kernel from the currently running
  one. You can perform faster system reboots without any hardware
  initialization. You can also prepare the system to boot to another kernel
  if the system crashes.
 </p><div class="sect1 " id="cha.tuning.kexec.intro"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kexec.intro"><span class="number">17.1 </span><span class="name">Introduction</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kexec.intro">#</a></h2></div></div></div><p>
   With Kexec, you can replace the running kernel with another one
   without a hard reboot. The tool is useful for several reasons:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     Faster system rebooting
    </p><p>
     If you need to reboot the system frequently, Kexec can save you
     significant time.
    </p></li><li class="listitem "><p>
     Avoiding unreliable firmware and hardware
    </p><p>
     Computer hardware is complex and serious problems may occur during the
     system start-up. You cannot always replace unreliable hardware
     immediately. Kexec boots the kernel to a controlled environment
     with the hardware already initialized. The risk of unsuccessful system
     start is then minimized.
    </p></li><li class="listitem "><p>
     Saving the dump of a crashed kernel
    </p><p>
     Kexec preserves the contents of the physical memory. After the
     <span class="emphasis"><em>production</em></span> kernel fails, the
     <span class="emphasis"><em>capture</em></span> kernel (an additional kernel running in a
     reserved memory range) saves the state of the failed kernel. The saved
     image can help you with the subsequent analysis.
    </p></li><li class="listitem "><p>
     Booting without GRUB 2 configuration
    </p><p>
     When the system boots a kernel with Kexec, it skips the boot
     loader stage. The normal booting procedure can fail because of an error
     in the boot loader configuration. With Kexec, you do not depend on
     a working boot loader configuration.
    </p></li></ul></div></div><div class="sect1 " id="cha.tuning.kexec.pkgs"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kexec.pkgs"><span class="number">17.2 </span><span class="name">Required Packages</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kexec.pkgs">#</a></h2></div></div></div><p>
   To use Kexec on <span class="productname"><span class="phrase">openSUSE® Leap</span></span> to speed up reboots or avoid potential
   hardware problems, make sure that the package
   <code class="systemitem">kexec-tools</code> is installed.
   It contains a script called
   <code class="command">kexec-bootloader</code>, which reads the boot loader
   configuration and runs Kexec using the same kernel options as the
   normal boot loader.
  </p><p>
   To set up an environment that helps you obtain debug information
   in case of a kernel crash, make sure that the package
   <code class="systemitem">makedumpfile</code> is installed.
  </p><p>
   The preferred method of using Kdump in <span class="productname"><span class="phrase">openSUSE Leap</span></span> is through
   the YaST Kdump module.
   To use the YaST module, make sure that the package
   <code class="literal">yast2-kdump</code> is installed.
  </p></div><div class="sect1 " id="cha.tuning.kexec.internals"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kexec.internals"><span class="number">17.3 </span><span class="name">Kexec Internals</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kexec.internals">#</a></h2></div></div></div><p>
   The most important component of Kexec is the
   <code class="filename">/sbin/kexec</code> command. You can load a kernel with
   Kexec in two different ways:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     Load the kernel to the address space of a production kernel for a regular
     reboot:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">kexec</code> <code class="option">-l</code> <em class="replaceable ">KERNEL_IMAGE</em></pre></div><p>
     You can later boot to this kernel with
     <code class="command">kexec</code> <code class="option">-e</code>.
    </p></li><li class="listitem "><p>
     Load the kernel to a reserved area of memory:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">kexec</code> <code class="option">-p</code> <em class="replaceable ">KERNEL_IMAGE</em></pre></div><p>
     This kernel will be booted automatically when the system crashes.
    </p></li></ul></div><p>
   If you want to boot another kernel and preserve the data of the
   production kernel when the system crashes, you need to reserve a
   dedicated area of the system memory. The production kernel never loads to
   this area because it must be always available. It is used for the capture
   kernel so that the memory pages of the production kernel can be
   preserved.
  </p><p>
   To reserve the area, append the option <code class="option">crashkernel</code>
   to the boot command line of the production kernel.
   To determine the necessary values for <code class="option">crashkernel</code>, follow
   the instructions in <a class="xref" href="cha.tuning.kexec.html#sec.tuning.kexec.crashkernel" title="17.4. Calculating crashkernel Allocation Size">Section 17.4, “Calculating <code class="option">crashkernel</code> Allocation Size”</a>.
  </p><p>
   Note that this is not a parameter of the capture
   kernel. The capture kernel does not use Kexec.
  </p><p>
   The capture kernel is loaded to the reserved area and waits for the
   kernel to crash. Then, Kdump tries to invoke the capture kernel
   because the production kernel is no longer reliable at this stage. This
   means that even Kdump can fail.
  </p><p>
   To load the capture kernel, you need to include the kernel boot
   parameters. Usually, the initial RAM file system is used for booting. You
   can specify it with
   <code class="option">--initrd</code><code class="literal">=</code><em class="replaceable ">FILENAME</em>.
   With
   <code class="option">--append</code><code class="literal">=</code><em class="replaceable ">CMDLINE</em>,
   you append options to the command line of the kernel to boot.
  </p><p>
   It is helpful to include the command line of
   the production kernel if these options are necessary for the kernel to
   boot. You can simply copy the command line with
   <code class="option">--append</code><code class="literal">=</code><em class="replaceable ">"$(cat /proc/cmdline)"</em>
   or add more options with
   <code class="option">--append</code><code class="literal">=</code><em class="replaceable ">"$(cat /proc/cmdline) more_options"</em>.
  </p><p>
   You can always unload the previously loaded kernel. To unload a kernel
   that was loaded with the <code class="option">-l</code> option, use the
   <code class="command">kexec</code> <code class="option">-u</code> command. To unload a crash
   kernel loaded with the <code class="option">-p</code> option, use
   <code class="command">kexec</code> <code class="option">-p</code> <code class="option">-u</code> command.
  </p></div><div class="sect1 " id="sec.tuning.kexec.crashkernel"><div class="titlepage"><div><div><h2 class="title" id="sec.tuning.kexec.crashkernel"><span class="number">17.4 </span><span class="name">Calculating <code class="option">crashkernel</code> Allocation Size</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#sec.tuning.kexec.crashkernel">#</a></h2></div></div></div><p>
   To use Kexec with a capture kernel and to use Kdump in any way, RAM needs
   to be allocated for the capture kernel.
   The allocation size depends on the expected hardware configuration of
   the computer, therefore you need to specify it.
  </p><p>
   The allocation size also depends on the hardware architecture of your
   computer.
   Make sure to follow the procedure intended for your system architecture.
  </p><div class="procedure " id="idm140167159223056"><div class="procedure-title-wrap"><h6 class="procedure-title"><span class="number">Procedure 17.1: </span><span class="name">Allocation Size on AMD64/Intel 64 </span><a title="Permalink" class="permalink" href="cha.tuning.kexec.html#idm140167159223056">#</a></h6></div><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     To find out the base value for the computer, run the following in a
     terminal:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">kdumptool</code> calibrate</pre></div><p>
     This command returns a list of values.
     All values are given in megabytes.
    </p></li><li class="step "><p>
     Write down the values of <code class="literal">Low</code> and
     <code class="literal">High</code>.
    </p><div id="idm140167159217904" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.png" /><h6>Note: 
      Significance of <code class="literal">Low</code> and <code class="literal">High</code> Values
     </h6><p>
      On AMD64/Intel 64 computers, the <code class="literal">High</code> value stands
      for the memory reservation for all available memory.
      The <code class="literal">Low</code> value stands for the memory reservation
      in the DMA32 zone, that is, all the memory up to the 4 GB mark.
      
     </p><p>
      
      If the computer has less than 4 GB of RAM, the
      <code class="literal">High</code> memory reservation is allocated and the
      <code class="literal">Low</code> memory reservation is ignored.
      If the computer has more than 4 GB of RAM, the <code class="literal">Low</code>
      memory reservation is allocated additionally.
     </p></div></li><li class="step "><p>
      Adapt the <code class="literal">High</code> value from the previous step for
      the number of LUN kernel paths (paths to storage devices) attached to the
      computer.
      A sensible value in megabytes can be calculated using this formula:
     </p><div class="verbatim-wrap"><pre class="screen">SIZE_HIGH = <em class="replaceable ">RECOMMENDATION</em> + (<em class="replaceable ">LUNs</em> / 2)</pre></div><p>
      The following parameters are used in this formula:
     </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p><span class="formalpara-title">SIZE_HIGH. </span>
         The resulting value for <code class="literal">High</code>.
        </p></li><li class="listitem "><p><span class="formalpara-title">RECOMMENDATION. </span>
         The value recommended by <code class="command">kdumptool calibrate</code>
         for <code class="literal">High</code>.
        </p></li><li class="listitem "><p><span class="formalpara-title">LUNs. </span>
         The maximum number of LUN kernel paths that you expect to ever create
         on the computer.
         Exclude multipath devices from this number, as these are
         ignored.
        </p></li></ul></div><div id="idm140167159200064" class="admonition important normal"><img class="symbol" alt="Important" title="Important" src="static/images/icon-important.png" /><h6>Important: Adjust for Large Amounts of RAM</h6><p>
       For machines that have multiple terabytes (!) of RAM, such as many
       servers running SAP HANA, you need to additionally adjust the
       amount of both Kdump High and Low Memory.
      </p><p>
       Experience suggests that in such cases, you might be successful using
       the following formulas:
      </p><div class="verbatim-wrap"><pre class="screen">SIZE_HIGH = (<em class="replaceable ">RECOMMENDATION</em> * <em class="replaceable ">RAM_IN_TB</em>) + (<em class="replaceable ">LUNs</em> / 2)</pre></div><div class="verbatim-wrap"><pre class="screen">SIZE_LOW = (<em class="replaceable ">RECOMMENDATION</em> * <em class="replaceable ">RAM_IN_TB</em>) + <em class="replaceable ">CUSTOM_DRIVER-RESERVATION_ADJUSTMENT</em></pre></div></div></li><li class="step "><p>
      If the drivers for your device make many reservations in the DMA32 zone,
      the <code class="literal">Low</code> value also needs to be adjusted.
      However, there is no simple formula to calculate these.
      Finding the right size can therefore be a process of trial and error.
     </p><p>
      For the beginning, use the <code class="literal">Low</code> value recommended by
      <code class="command">kdumptool calibrate</code>.
     </p></li><li class="step "><p>
      The values now need to be set in the correct location.
     </p><div class="variablelist "><dl class="variablelist"><dt id="idm140167159190352"><span class="term ">If you are changing the kernel command line directly</span></dt><dd><p>
         Append the following kernel option to your boot loader
         configuration:
        </p><div class="verbatim-wrap"><pre class="screen">crashkernel=<em class="replaceable ">SIZE_HIGH</em>,high crashkernel=<em class="replaceable ">SIZE_LOW</em>,low</pre></div><p>
         Replace the placeholders <em class="replaceable ">SIZE_HIGH</em> and
         <em class="replaceable ">SIZE_LOW</em> with the appropriate value from the
         previous steps and append the letter <code class="literal">M</code>
         (for megabytes).
        </p><p>
         As an example, the following is valid:
        </p><div class="verbatim-wrap"><pre class="screen">crashkernel=<em class="replaceable ">36M</em>,high crashkernel=<em class="replaceable ">72M</em>,low</pre></div></dd><dt id="idm140167159183376"><span class="term ">If you are using the YaST GUI:</span></dt><dd><p>
         Set <span class="guimenu">Kdump Low Memory</span> to the determined
         <code class="literal">Low</code> value.
        </p><p>
         Set <span class="guimenu">Kdump High Memory</span> to the determined
         <code class="literal">High</code> value.
        </p></dd><dt id="idm140167159179296"><span class="term ">If you are using the YaST command line interface:</span></dt><dd><p>
         Use the following command:
        </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>yast kdump startup enable alloc_mem=<em class="replaceable ">LOW</em>,<em class="replaceable ">HIGH</em></pre></div><p>
         Replace <em class="replaceable ">LOW</em> with the determined
         <code class="literal">Low</code> value. Replace
         <em class="replaceable ">HIGH</em> with the determined
         <code class="literal">HIGH</code> value.
        </p></dd></dl></div></li></ol></div></div><div class="procedure " id="idm140167159172912"><div class="procedure-title-wrap"><h6 class="procedure-title"><span class="number">Procedure 17.2: </span><span class="name">Allocation Size on POWER and z Systems </span><a title="Permalink" class="permalink" href="cha.tuning.kexec.html#idm140167159172912">#</a></h6></div><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     To find out the basis value for the computer, run the following in a
     terminal:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">kdumptool</code> calibrate</pre></div><p>
     This command returns a list of values.
     All values are given in megabytes.
    </p></li><li class="step "><p>
     Write down the value of <code class="literal">Low</code>.
    </p></li><li class="step "><p>
     Adapt the <code class="literal">Low</code> value from the previous step for
     the number of LUN kernel paths (paths to storage devices) attached to the
     computer.
     A sensible value in megabytes can be calculated using this formula:
    </p><div class="verbatim-wrap"><pre class="screen">SIZE_LOW = <em class="replaceable ">RECOMMENDATION</em> + (<em class="replaceable ">LUNs</em> / 2)</pre></div><p>
     The following parameters are used in this formula:
    </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p><span class="formalpara-title">SIZE_LOW. </span>
        The resulting value for <code class="literal">Low</code>.
       </p></li><li class="listitem "><p><span class="formalpara-title">RECOMMENDATION. </span>
        The value recommended by <code class="command">kdumptool calibrate</code>
        for <code class="literal">Low</code>.
       </p></li><li class="listitem "><p><span class="formalpara-title">LUNs. </span>
        The maximum number of LUN kernel paths that you expect to ever create
        on the computer.
        Exclude multipath devices from this number, as these are
        ignored.
       </p></li></ul></div></li><li class="step "><p>
     The values now need to be set in the correct location.
    </p><div class="variablelist "><dl class="variablelist"><dt id="idm140167159156176"><span class="term ">If you are working on the command line</span></dt><dd><p>
        Append the following kernel option to your boot loader
        configuration:
       </p><div class="verbatim-wrap"><pre class="screen">crashkernel=<em class="replaceable ">SIZE_LOW</em></pre></div><p>
        Replace the placeholder<em class="replaceable ">SIZE_LOW</em> with the
        appropriate value from the previous step and append the letter
        <code class="literal">M</code> (for megabytes).
       </p><p>
        As an example, the following is valid:
       </p><div class="verbatim-wrap"><pre class="screen">crashkernel=<em class="replaceable ">108M</em></pre></div></dd><dt id="idm140167159150880"><span class="term ">If you are working in YaST</span></dt><dd><p>
        Set <span class="guimenu">Kdump Memory</span> to the determined
        <code class="literal">Low</code> value.
       </p></dd></dl></div></li></ol></div></div><div id="idm140167145145200" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Excluding Unused and Inactive CCW Devices on IBM z Systems</h6><p>
    Depending on the number of available devices the calculated amount of
    memory specified by the <code class="option">crashkernel</code> kernel parameter may
    not be sufficient. Instead of increasing the value, you may alternatively
    limit the amount of devices visible to the kernel. This will lower the
    required amount of memory for the "crashkernel" setting.
   </p><div class="orderedlist "><ol class="orderedlist" type="1"><li class="listitem "><p>
      To ignore devices you can run the <code class="command">cio_ignore</code> tool to
      generate an appropriate stanza to ignore all devices, except the ones
      currently active or in use.
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>sudo cio_ignore -u -k
cio_ignore=all,!da5d,!f500-f502</pre></div><p>
      When you run <code class="command">cio_ignore -u -k</code>, the blacklist will
      become active and replace any existing blacklist immediately. Unused
      devices are not being purged, so they still appear in the channel
      subsystem. But adding new channel devices (via CP ATTACH under z/VM or
      dynamic I/O configuration change in LPAR) will treat them as
      blacklisted. To prevent this, preserve the original setting by running
      <code class="command">sudo cio_ignore -l</code> first and reverting to that
      state after running <code class="command">cio_ignore -u -k</code>. As an
      alternative, add the generated stanza to the regular kernel boot
      parameters.
     </p></li><li class="listitem "><p>
      Now add the <code class="option">cio_ignore</code> kernel parameter with the stanza
      from above to <code class="envar">KDUMP_CMDLINE_APPEND</code> in
      <code class="filename">/etc/sysconfig/kdump</code>, for example:
     </p><div class="verbatim-wrap"><pre class="screen">KDUMP_COMMANDLINE_APPEND="cio_ignore=all,!da5d,!f500-f502"</pre></div></li><li class="listitem "><p>
      Activate the setting by restarting <code class="systemitem">kdump</code>:
     </p><div class="verbatim-wrap"><pre class="screen">systemctl restart kdump.service</pre></div></li></ol></div></div></div><div class="sect1 " id="cha.tuning.kexec.basic_usage"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kexec.basic_usage"><span class="number">17.5 </span><span class="name">Basic Kexec Usage</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kexec.basic_usage">#</a></h2></div></div></div><p>
   To verify if your Kexec environment works properly, follow these
   steps:
  </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Make sure no users are currently logged in and no important services
     are running on the system.
    </p></li><li class="step "><p>
     Log in as <code class="systemitem">root</code>.
    </p></li><li class="step "><p>
     Switch to the rescue target with <code class="command">systemctl isolate
     rescue.target</code>
    </p></li><li class="step " id="step.kexec.usage.load.kernel"><p>
     Load the new kernel to the address space of the production kernel with
     the following command:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">kexec</code> -l <em class="replaceable ">/boot/vmlinuz</em> --append=<em class="replaceable ">"$(cat /proc/cmdline)"</em> \
--initrd=<em class="replaceable ">/boot/initrd</em></pre></div></li><li class="step "><p>
     Unmount all mounted file systems except the root file system with:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="command">umount</code> <code class="option">-a</code></pre></div><div id="idm140167145121232" class="admonition important normal"><img class="symbol" alt="Important" title="Important" src="static/images/icon-important.png" /><h6>Important: Unmounting the Root File System</h6><p>
      Unmounting all file systems will most likely produce a <code class="literal">device
      is busy</code> warning message. The root file system cannot be
      unmounted if the system is running. Ignore the warning.
     </p></div></li><li class="step "><p>
     Remount the root file system in read-only mode:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">mount</code> -o remount,ro /</pre></div></li><li class="step "><p>
     Initiate the reboot of the kernel that you loaded in
     <a class="xref" href="cha.tuning.kexec.html#step.kexec.usage.load.kernel" title="Step 4">Step 4</a> with:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">kexec</code> -e</pre></div></li></ol></div></div><p>
   It is important to unmount the previously mounted disk volumes in
   read-write mode. The <code class="systemitem">reboot</code> system call acts
   immediately upon calling. Hard disk volumes mounted in read-write mode
   neither synchronize nor unmount automatically. The new kernel may find
   them <span class="quote">“<span class="quote">dirty</span>”</span>. Read-only disk volumes and virtual file
   systems do not need to be unmounted. Refer to
   <code class="filename">/etc/mtab</code> to determine which file systems you need
   to unmount.
  </p><p>
   The new kernel previously loaded to the address space of the older kernel
   rewrites it and takes control immediately. It displays the usual start-up
   messages. When the new kernel boots, it skips all hardware and firmware
   checks. Make sure no warning messages appear. All file systems are
   supposed to be clean if they had been unmounted.
  </p></div><div class="sect1 " id="cha.tuning.kexec.config"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kexec.config"><span class="number">17.6 </span><span class="name">How to Configure Kexec for Routine Reboots</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kexec.config">#</a></h2></div></div></div><p>
   Kexec is often used for frequent reboots. For example, if it takes a
   long time to run through the hardware detection routines or if the
   start-up is not reliable.
  </p><p>
   Note that firmware and the boot loader are not used when the
   system reboots with Kexec. Any changes you make to the boot loader
   configuration will be ignored until the computer performs a hard reboot.
  </p></div><div class="sect1 " id="cha.tuning.kdump.basic"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kdump.basic"><span class="number">17.7 </span><span class="name">Basic Kdump Configuration</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.basic">#</a></h2></div></div></div><p>
   You can use Kdump to save kernel dumps. If the kernel crashes, it is
   useful to copy the memory image of the crashed environment to the file
   system. You can then debug the dump file to find the cause of the kernel
   crash. This is called <span class="quote">“<span class="quote">core dump</span>”</span>.
  </p><p>
   Kdump works similarly to Kexec (see
   <a class="xref" href="cha.tuning.kexec.html" title="Chapter 17. Kexec and Kdump">Chapter 17, <em>Kexec and Kdump</em></a>). The capture kernel is executed after
   the running production kernel crashes. The difference is that Kexec
   replaces the production kernel with the capture kernel. With Kdump,
   you still have access to the memory space of the crashed production
   kernel. You can save the memory snapshot of the crashed kernel in the
   environment of the Kdump kernel.
  </p><div id="idm140167145104592" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Dumps over Network</h6><p>
    In environments with limited local storage, you need to set up kernel
    dumps over the network. Kdump supports configuring the specified
    network interface and bringing it up via
    <code class="systemitem">initrd</code>. Both LAN and VLAN interfaces are
    supported. Specify the network interface and the mode (DHCP or static)
    either with YaST, or using the <code class="option">KDUMP_NETCONFIG</code>
    option in the <code class="filename">/etc/sysconfig/kdump</code> file.
   </p></div><div id="idm140167145101600" class="admonition important normal"><img class="symbol" alt="Important" title="Important" src="static/images/icon-important.png" /><h6>Important: Target File System for Kdump Must Be Mounted During Configuration</h6><p>
    When configuring Kdump, you can specify a location to which the
    dumped images will be saved (default: <code class="filename">/var/crash</code>).
    This location must be mounted when configuring Kdump, otherwise the
    configuration will fail.
   </p></div><div class="sect2 " id="cha.tuning.kdump.basic.manual"><div class="titlepage"><div><div><h3 class="title" id="cha.tuning.kdump.basic.manual"><span class="number">17.7.1 </span><span class="name">Manual Kdump Configuration</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.basic.manual">#</a></h3></div></div></div><p>
    Kdump reads its configuration from the
    <code class="filename">/etc/sysconfig/kdump</code> file. To make sure that
    Kdump works on your system, its default configuration is
    sufficient. To use Kdump with the default settings, follow these
    steps:
   </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      Determine the amount of memory needed for Kdump by following the
      instructions in <a class="xref" href="cha.tuning.kexec.html#sec.tuning.kexec.crashkernel" title="17.4. Calculating crashkernel Allocation Size">Section 17.4, “Calculating <code class="option">crashkernel</code> Allocation Size”</a>.
      Make sure to set the kernel parameter <code class="option">crashkernel</code>.
     </p></li><li class="step "><p>
      Reboot the computer.
     </p></li><li class="step "><p>
      Enable the Kdump service:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">systemctl</code> enable kdump</pre></div></li><li class="step "><p>
      You can edit the options in <code class="filename">/etc/sysconfig/kdump</code>.
      Reading the comments will help you understand the meaning of
      individual options.
     </p></li><li class="step "><p>
      Execute the init script once with <code class="command">sudo systemctl start
      kdump</code>, or reboot the system.
     </p></li></ol></div></div><p>
    After configuring Kdump with the default values, check if it works
    as expected. Make sure that no users are currently logged in and no
    important services are running on your system. Then follow these steps:
   </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      Switch to the rescue target with <code class="command">systemctl isolate
      rescue.target</code>
     </p></li><li class="step "><p>
      Restart the Kdump service:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">systemctl</code> start kdump</pre></div></li><li class="step "><p>
      Unmount all the disk file systems except the root file system with:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">umount</code> -a</pre></div></li><li class="step "><p>
      Remount the root file system in read-only mode:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">mount</code> -o remount,ro /</pre></div></li><li class="step "><p>
      Invoke a <span class="quote">“<span class="quote">kernel panic</span>”</span> with the <code class="literal">procfs</code>
      interface to Magic SysRq keys:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">echo</code> c &gt; /proc/sysrq-trigger</pre></div></li></ol></div></div><div id="idm140167145076032" class="admonition important normal"><img class="symbol" alt="Important" title="Important" src="static/images/icon-important.png" /><h6>Important: Size of Kernel Dumps</h6><p>
     The <code class="literal">KDUMP_KEEP_OLD_DUMPS</code> option controls the number
     of preserved kernel dumps (default is 5). Without compression, the size
     of the dump can take up to the size of the physical RAM memory. Make
     sure you have sufficient space on the <code class="filename">/var</code>
     partition.
    </p></div><p>
    The capture kernel boots and the crashed kernel memory snapshot is saved
    to the file system. The save path is given by the
    <code class="literal">KDUMP_SAVEDIR</code> option and it defaults to
    <code class="filename">/var/crash</code>. If
    <code class="literal">KDUMP_IMMEDIATE_REBOOT</code> is set to
    <code class="literal">yes</code> , the system automatically reboots the production
    kernel. Log in and check that the dump has been created under
    <code class="filename">/var/crash</code>.
   </p><div class="sect3 " id="sec.tuning.kdump.basic.manual.static_ip"><div class="titlepage"><div><div><h4 class="title" id="sec.tuning.kdump.basic.manual.static_ip"><span class="number">17.7.1.1 </span><span class="name">Static IP Configuration for Kdump</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#sec.tuning.kdump.basic.manual.static_ip">#</a></h4></div></div></div><p>
     In case Kdump is configured to use a static IP configuration from a
     network device, you need to add the network configuration to the
     <code class="envar">KDUMP_COMMANDLINE_APPEND</code> variable in
     <code class="filename">/etc/sysconfig/kdump</code>.
    </p><div class="complex-example"><div class="example" id="idm140167145067936"><div class="example-title-wrap"><h6 class="example-title"><span class="number">Example 17.1: </span><span class="name">Kdump: Example Configuration Using a Static IP Setup </span><a title="Permalink" class="permalink" href="cha.tuning.kexec.html#idm140167145067936">#</a></h6></div><div class="example-contents"><p>
      The following setup has been configured:
     </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
        eth0 has been configured with the static IP address <code class="systemitem">192.168.1.1/24</code>
       </p></li><li class="listitem "><p>
        eth1 has been configured with the static IP address <code class="systemitem">10.50.50.100/20</code>
       </p></li><li class="listitem "><p>
        The Kdump configuration in <code class="filename">/etc/sysconfig/kdump</code>
        looks like:
       </p><div class="verbatim-wrap"><pre class="screen">KDUMP_CPUS=1
KDUMP_IMMEDIATE_REBOOT=yes
KDUMP_SAVEDIR=ftp://anonymous@10.50.50.140/crashdump/
KDUMP_KEEP_OLD_DUMPS=5
KDUMP_FREE_DISK_SIZE=64
KDUMP_VERBOSE=3
KDUMP_DUMPLEVEL=31
KDUMP_DUMPFORMAT=lzo
KDUMP_CONTINUE_ON_ERROR=yes
KDUMP_NETCONFIG=eth1:static
KDUMP_NET_TIMEOUT=30</pre></div></li></ul></div><p>
      Using this configuration, Kdump fails to reach the network when trying
      to write the dump to the FTP server. To solve this issue, add the network
      configuration to <code class="envar">KDUMP_COMMANDLINE_APPEND</code> in
      <code class="filename">/etc/sysconfig/kdump</code>. The general pattern for this
      looks like the following:
     </p><div class="verbatim-wrap"><pre class="screen">KDUMP_COMMANDLINE_APPEND='ip=<em class="replaceable ">CLIENT IP</em>:<em class="replaceable ">SERVER IP</em>:<em class="replaceable ">GATEWAY IP</em>:<em class="replaceable ">NETMASK</em>:<em class="replaceable ">CLIENT HOSTNAME</em>:<em class="replaceable ">DEVICE</em>:<em class="replaceable ">PROTOCOL</em>'</pre></div><p>
      For the example configuration this would result in:
     </p><div class="verbatim-wrap"><pre class="screen">KDUMP_COMMANDLINE_APPEND='ip=10.50.50.100:10.50.50.140:10.60.48.1:255.255.240.0:dump-client:eth1:none'</pre></div></div></div></div></div></div><div class="sect2 " id="cha.tuning.kdump.basic.yast"><div class="titlepage"><div><div><h3 class="title" id="cha.tuning.kdump.basic.yast"><span class="number">17.7.2 </span><span class="name">YaST Configuration</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.basic.yast">#</a></h3></div></div></div><p>
    To configure Kdump with YaST, you need to install the
    <code class="systemitem">yast2-kdump</code> package. Then either start the
    <span class="guimenu">Kernel Kdump</span> module in the <span class="guimenu">System</span>
    category of <span class="guimenu">YaST Control Center</span>, or enter <code class="command">yast2 kdump</code> in the
    command line as <code class="systemitem">root</code>.
   </p><div class="figure" id="fig.tuning.kdump.basic.yast.kdump1"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/yast2_kdump_startup.png"><img src="images/yast2_kdump_startup.png" width="" alt="Screenshot of the YaST Kdump Module" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 17.1: </span><span class="name">YaST Kdump Module: Start-Up Page </span><a title="Permalink" class="permalink" href="cha.tuning.kexec.html#fig.tuning.kdump.basic.yast.kdump1">#</a></h6></div></div><p>
    In the <span class="guimenu">Start-Up</span> window, select <span class="guimenu">Enable
    Kdump</span>.
   </p><p>
    The values for <span class="guimenu">Kdump Memory</span> are automatically generated
    the first time you open the window.
    However, that does not mean that they are always sufficient.
    To set the right values, follow the instructions in
    <a class="xref" href="cha.tuning.kexec.html#sec.tuning.kexec.crashkernel" title="17.4. Calculating crashkernel Allocation Size">Section 17.4, “Calculating <code class="option">crashkernel</code> Allocation Size”</a>.
   </p><div id="idm140167145040144" class="admonition important normal"><img class="symbol" alt="Important" title="Important" src="static/images/icon-important.png" /><h6>Important: 
     After Hardware Changes, Set <span class="guimenu">Kdump Memory</span> Values Again
    </h6><p>
     If you have set up Kdump on a computer and later decide to change the
     amount of RAM or hard disks available to it, YaST will continue to
     display and use outdated memory values.
    </p><p>
     To work around this, determine the necessary memory again, as described in
     <a class="xref" href="cha.tuning.kexec.html#sec.tuning.kexec.crashkernel" title="17.4. Calculating crashkernel Allocation Size">Section 17.4, “Calculating <code class="option">crashkernel</code> Allocation Size”</a>.
     Then set it manually in YaST.
    </p></div><p>
    Click <span class="guimenu">Dump Filtering</span> in the left pane, and check what
    pages to include in the dump. You do not need to include the following
    memory content to be able to debug kernel problems:
   </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
      Pages filled with zero
     </p></li><li class="listitem "><p>
      Cache pages
     </p></li><li class="listitem "><p>
      User data pages
     </p></li><li class="listitem "><p>
      Free pages
     </p></li></ul></div><p>
    In the <span class="guimenu">Dump Target</span> window, select the type of the
    dump target and the URL where you want to save the dump. If you selected
    a network protocol, such as FTP or SSH, you need to enter relevant
    access information as well.
   </p><div id="idm140167145030272" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Sharing the Dump Directory with Other Applications</h6><p>
     It is possible to specify a path for saving Kdump dumps where
     other applications also save their dumps. When cleaning its old dump
     files, Kdump will safely ignore other applications' dump files.
    </p></div><p>
    Fill the <span class="guimenu">Email Notification</span> window information if you
    want Kdump to inform you about its events via e-mail and confirm
    your changes with <span class="guimenu">OK</span> after fine tuning Kdump in
    the <span class="guimenu">Expert Settings</span> window. Kdump is now
    configured.
   </p></div></div><div class="sect1 " id="cha.tuning.kdump.analyze"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kdump.analyze"><span class="number">17.8 </span><span class="name">Analyzing the Crash Dump</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.analyze">#</a></h2></div></div></div><p>
   After you obtain the dump, it is time to analyze it. There are several
   options.
  </p><p>
   The original tool to analyze the dumps is GDB. You can even use it in the
   latest environments, although it has several disadvantages and
   limitations:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     GDB was not specifically designed to debug kernel dumps.
    </p></li><li class="listitem "><p>
     GDB does not support ELF64 binaries on 32-bit platforms.
    </p></li><li class="listitem "><p>
     GDB does not understand other formats than ELF dumps (it cannot debug
     compressed dumps).
    </p></li></ul></div><p>
   That is why the <code class="command">crash</code> utility was implemented. It
   analyzes crash dumps and debugs the running system as well. It provides
   functionality specific to debugging the Linux kernel and is much more
   suitable for advanced debugging.
  </p><p>
   If you want to debug the Linux kernel, you need to install its debugging
   information package in addition. Check if the package is installed on
   your system with:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">zypper</code> se kernel | <code class="command">grep</code> debug</pre></div><div id="idm140167145017072" class="admonition important normal"><img class="symbol" alt="Important" title="Important" src="static/images/icon-important.png" /><h6>Important: Repository for Packages with Debugging Information</h6><p>
    If you subscribed your system for online updates, you can find
    <span class="quote">“<span class="quote">debuginfo</span>”</span> packages in the
    <code class="literal">*-Debuginfo-Updates</code> online installation repository
    relevant for <span class="productname"><span class="phrase">openSUSE Leap</span></span> <span class="productnumber"><span class="phrase">42.3</span></span>. Use YaST to
    enable the repository.
   </p></div><p>
   To open the captured dump in <code class="command">crash</code> on the machine that
   produced the dump, use a command like this:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="command">crash</code> <em class="replaceable ">/boot/vmlinux-2.6.32.8-0.1-default.gz</em> \
<em class="replaceable ">/var/crash/2010-04-23-11\:17/vmcore</em></pre></div><p>
   The first parameter represents the kernel image. The second parameter is
   the dump file captured by Kdump. You can find this file under
   <code class="filename">/var/crash</code> by default.
  </p><div id="idm140167145008944" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Getting Basic Information from a Kernel Crash Dump</h6><p>
    <span class="productname"><span class="phrase">openSUSE Leap</span></span> ships with the utility <code class="command">kdumpid</code>
    (included in a package with the same name) for identifying unknown
    kernel dumps. It can be used to extract basic information such as
    architecture and kernel release. It supports lkcd, diskdump, Kdump
    files and ELF dumps. When called with the <code class="option">-v</code>
    switch it tries to extract additional information such as machine type,
    kernel banner string and kernel configuration flavor.
   </p></div><div class="sect2 " id="cha.tuning.kdump.analyze.binformat"><div class="titlepage"><div><div><h3 class="title" id="cha.tuning.kdump.analyze.binformat"><span class="number">17.8.1 </span><span class="name">Kernel Binary Formats</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.analyze.binformat">#</a></h3></div></div></div><p>
    The Linux kernel comes in Executable and Linkable Format (ELF). This
    file is usually called <code class="literal">vmlinux</code> and is directly
    generated in the compilation process. Not all boot loaders support
    ELF binaries, especially on the AMD64/Intel 64 architecture.
    The following solutions exist on different architectures supported by
    <span class="productname"><span class="phrase">openSUSE® Leap</span></span>.
   </p><div class="sect3 " id="cha.tuning.kdump.analyze.binformat.x86"><div class="titlepage"><div><div><h4 class="title" id="cha.tuning.kdump.analyze.binformat.x86"><span class="number">17.8.1.1 </span><span class="name">AMD64/Intel 64</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.analyze.binformat.x86">#</a></h4></div></div></div><p>
     Kernel packages for AMD64/Intel 64 from SUSE contain two kernel
     files: <code class="filename">vmlinuz</code> and <code class="filename">vmlinux.gz</code>.
    </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p><span class="formalpara-title"><code class="filename">vmlinuz</code>. </span>
        This is the file executed by the boot loader.
       </p><p>
       The Linux kernel consists of two parts:
       the kernel itself (<code class="literal">vmlinux</code>) and the setup code
       run by the boot loader.
       These two parts are linked together to create
       <code class="filename">vmlinuz</code>
       (note the distinction: <code class="literal">z</code> compared to <code class="literal">x</code>).
      </p><p>
       In the kernel source tree, the file is called
       <code class="filename">bzImage</code>.
      </p></li><li class="listitem "><p><span class="formalpara-title"><code class="filename">vmlinux.gz</code>. </span>
        This is a compressed ELF image that can be used by
        <code class="command">crash</code> and GDB.
        The ELF image is never used by the boot loader itself on AMD64/Intel 64.
        Therefore, only a compressed version is shipped.
       </p></li></ul></div></div><div class="sect3 " id="cha.tuning.kdump.analyze.binformat.ppc"><div class="titlepage"><div><div><h4 class="title" id="cha.tuning.kdump.analyze.binformat.ppc"><span class="number">17.8.1.2 </span><span class="name">POWER</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.analyze.binformat.ppc">#</a></h4></div></div></div><p>
     The <code class="systemitem">yaboot</code> boot loader on POWER also supports
     loading ELF images, but not compressed ones. In the POWER kernel package,
     there is an ELF Linux kernel file <code class="filename">vmlinux</code>.
     Considering <code class="command">crash</code>, this is the easiest
     architecture.
    </p><p>
     If you decide to analyze the dump on another machine, you must check
     both the architecture of the computer and the files necessary for
     debugging.
    </p><p>
     You can analyze the dump on another computer only if it runs a Linux
     system of the same architecture. To check the compatibility, use the
     command <code class="command">uname</code> <code class="option">-i</code> on both computers
     and compare the outputs.
    </p><p>
     If you are going to analyze the dump on another computer, you also need
     the appropriate files from the <code class="systemitem">kernel</code> and
     <code class="systemitem">kernel debug</code> packages.
    </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
       Put the kernel dump, the kernel image from
       <code class="filename">/boot</code>, and its associated debugging info file
       from <code class="filename">/usr/lib/debug/boot</code> into a single empty
       directory.
      </p></li><li class="step "><p>
       Additionally, copy the kernel modules from
       <code class="filename">/lib/modules/$(uname -r)/kernel/</code> and the
       associated debug info files from
       <code class="filename">/usr/lib/debug/lib/modules/$(uname -r)/kernel/</code>
       into a subdirectory named <code class="filename">modules</code>.
      </p></li><li class="step "><p>
       In the directory with the dump, the kernel image, its debug info
       file, and the <code class="filename">modules</code> subdirectory, start the
       <code class="command">crash</code> utility:
      </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">crash</code> <em class="replaceable ">VMLINUX-VERSION vmcore</em></pre></div></li></ol></div></div><p>
     Regardless of the computer on which you analyze the dump, the crash
     utility will produce output similar to this:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">crash</code> <em class="replaceable ">/boot/vmlinux-2.6.32.8-0.1-default.gz</em> \
<em class="replaceable ">/var/crash/2010-04-23-11\:17/vmcore</em>

crash 4.0-7.6
Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008  Red Hat, Inc.
Copyright (C) 2004, 2005, 2006  IBM Corporation
Copyright (C) 1999-2006  Hewlett-Packard Co
Copyright (C) 2005, 2006  Fujitsu Limited
Copyright (C) 2006, 2007  VA Linux Systems Japan K.K.
Copyright (C) 2005  NEC Corporation
Copyright (C) 1999, 2002, 2007  Silicon Graphics, Inc.
Copyright (C) 1999, 2000, 2001, 2002  Mission Critical Linux, Inc.
This program is free software, covered by the GNU General Public License,
and you are welcome to change it and/or distribute copies of it under
certain conditions.  Enter "help copying" to see the conditions.
This program has absolutely no warranty.  Enter "help warranty" for details.

GNU gdb 6.1
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu"...

      KERNEL: /boot/vmlinux-2.6.32.8-0.1-default.gz
   DEBUGINFO: /usr/lib/debug/boot/vmlinux-2.6.32.8-0.1-default.debug
    DUMPFILE: /var/crash/2009-04-23-11:17/vmcore
        CPUS: 2
        DATE: Thu Apr 23 13:17:01 2010
      UPTIME: 00:10:41
LOAD AVERAGE: 0.01, 0.09, 0.09
       TASKS: 42
    NODENAME: eros
     RELEASE: 2.6.32.8-0.1-default
     VERSION: #1 SMP 2010-03-31 14:50:44 +0200
     MACHINE: x86_64  (2999 Mhz)
      MEMORY: 1 GB
       PANIC: "SysRq : Trigger a crashdump"
         PID: 9446
     COMMAND: "bash"
        TASK: ffff88003a57c3c0  [THREAD_INFO: ffff880037168000]
         CPU: 1
       STATE: TASK_RUNNING (SYSRQ)
<code class="prompt user">crash&gt; </code></pre></div><p>
     The command output prints first useful data: There were 42 tasks
     running at the moment of the kernel crash. The cause of the crash was a
     SysRq trigger invoked by the task with PID 9446. It was a Bash process
     because the <code class="command">echo</code> that has been used is an internal
     command of the Bash shell.
    </p><p>
     The <code class="command">crash</code> utility builds upon GDB and provides
     many additional commands. If you enter <code class="command">bt</code>
     without any parameters, the backtrace of the task running at the moment
     of the crash is printed:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">crash&gt; </code><code class="command">bt</code>
PID: 9446   TASK: ffff88003a57c3c0  CPU: 1   COMMAND: "bash"
 #0 [ffff880037169db0] crash_kexec at ffffffff80268fd6
 #1 [ffff880037169e80] __handle_sysrq at ffffffff803d50ed
 #2 [ffff880037169ec0] write_sysrq_trigger at ffffffff802f6fc5
 #3 [ffff880037169ed0] proc_reg_write at ffffffff802f068b
 #4 [ffff880037169f10] vfs_write at ffffffff802b1aba
 #5 [ffff880037169f40] sys_write at ffffffff802b1c1f
 #6 [ffff880037169f80] system_call_fastpath at ffffffff8020bfbb
    RIP: 00007fa958991f60  RSP: 00007fff61330390  RFLAGS: 00010246
    RAX: 0000000000000001  RBX: ffffffff8020bfbb  RCX: 0000000000000001
    RDX: 0000000000000002  RSI: 00007fa959284000  RDI: 0000000000000001
    RBP: 0000000000000002   R8: 00007fa9592516f0   R9: 00007fa958c209c0
    R10: 00007fa958c209c0  R11: 0000000000000246  R12: 00007fa958c1f780
    R13: 00007fa959284000  R14: 0000000000000002  R15: 00000000595569d0
    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b
<code class="prompt user">crash&gt; </code></pre></div><p>
     Now it is clear what happened: The internal <code class="command">echo</code>
     command of Bash shell sent a character to
     <code class="filename">/proc/sysrq-trigger</code>. After the corresponding
     handler recognized this character, it invoked the
     <code class="literal">crash_kexec()</code> function. This function called
     <code class="literal">panic()</code> and Kdump saved a dump.
    </p><p>
     In addition to the basic GDB commands and the extended version of
     <code class="command">bt</code>, the crash utility defines other commands
     related to the structure of the Linux kernel. These commands understand
     the internal data structures of the Linux kernel and present their
     contents in a human readable format. For example, you can list the
     tasks running at the moment of the crash with <code class="command">ps</code>.
     With <code class="command">sym</code>, you can list all the kernel symbols with
     the corresponding addresses, or inquire an individual symbol for its
     value. With <code class="command">files</code>, you can display all the open file
     descriptors of a process. With <code class="command">kmem</code>, you can display
     details about the kernel memory usage. With <code class="command">vm</code>, you
     can inspect the virtual memory of a process, even at the level of
     individual page mappings. The list of useful commands is very long and
     many of these accept a wide range of options.
    </p><p>
     The commands that we mentioned reflect the functionality of the common
     Linux commands, such as <code class="command">ps</code> and
     <code class="command">lsof</code>. To find out the exact sequence of
     events with the debugger, you need to know how to use GDB and to have
     strong debugging skills. Both of these are out of the scope of this
     document. In addition, you need to understand the Linux kernel. Several
     useful reference information sources are given at the end of this
     document.
    </p></div></div></div><div class="sect1 " id="cha.tuning.kdump.advanced"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kdump.advanced"><span class="number">17.9 </span><span class="name">Advanced Kdump Configuration</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.advanced">#</a></h2></div></div></div><p>
   The configuration for Kdump is stored in
   <code class="filename">/etc/sysconfig/kdump</code>. You can also use YaST to
   configure it. Kdump configuration options are available under
   <span class="guimenu">System</span> › <span class="guimenu">Kernel
   Kdump</span> in <span class="guimenu">YaST Control Center</span>. The following Kdump
   options may be useful for you.
  </p><p>
   You can change the directory for the kernel dumps with the
   <code class="option">KDUMP_SAVEDIR</code> option. Keep in mind that the size of
   kernel dumps can be very large. Kdump will refuse to save the dump
   if the free disk space, subtracted by the estimated dump size, drops
   below the value specified by the <code class="option">KDUMP_FREE_DISK_SIZE</code>
   option. Note that <code class="option">KDUMP_SAVEDIR</code> understands the URL format
   <em class="replaceable ">PROTOCOL://SPECIFICATION</em>, where
   <em class="replaceable ">PROTOCOL</em> is one of <code class="option">file</code>,
   <code class="option">ftp</code>, <code class="option">sftp</code>, <code class="option">nfs</code> or
   <code class="option">cifs</code>, and <code class="option">specification</code> varies for each
   protocol. For example, to save kernel dump on an FTP server, use the
   following URL as a template:
   <code class="option">ftp://username:password@ftp.example.com:123/var/crash</code>.
  </p><p>
   Kernel dumps are usually huge and contain many pages that are not
   necessary for analysis. With <code class="option">KDUMP_DUMPLEVEL</code> option,
   you can omit such pages. The option understands numeric value between 0
   and 31. If you specify <em class="replaceable ">0</em>, the dump size will
   be largest. If you specify <em class="replaceable ">31</em>, it will produce
   the smallest dump. For a complete table of possible values, see the
   manual page of <code class="command">kdump</code> (<code class="command">man 7 kdump</code>).
  </p><p>
   Sometimes it is very useful to make the size of the kernel dump smaller.
   For example, if you want to transfer the dump over the network, or if you
   need to save some disk space in the dump directory. This can be done with
   <code class="option">KDUMP_DUMPFORMAT</code> set to <code class="literal">compressed</code>. The
   <code class="command">crash</code> utility supports dynamic decompression of the
   compressed dumps.
  </p><div id="idm140167144942464" class="admonition important normal"><img class="symbol" alt="Important" title="Important" src="static/images/icon-important.png" /><h6>Important: Changes to the Kdump Configuration File</h6><p>
    You always need to execute <code class="command">systemctl restart kdump</code>
    after you make manual changes to
    <code class="filename">/etc/sysconfig/kdump</code>. Otherwise, these changes will
    take effect next time you reboot the system.
   </p></div></div><div class="sect1 " id="cha.tuning.kdump.moreinfo"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.kdump.moreinfo"><span class="number">17.10 </span><span class="name">For More Information</span> <a title="Permalink" class="permalink" href="cha.tuning.kexec.html#cha.tuning.kdump.moreinfo">#</a></h2></div></div></div><p>
   There is no single comprehensive reference to Kexec and Kdump
   usage. However, there are helpful resources that deal with certain
   aspects:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     For the Kexec utility usage, see the manual page of
     <code class="command">kexec</code> (<code class="command">man 8 kexec</code>).
    </p></li><li class="listitem "><p>
     IBM provides a comprehensive documentation on how to use dump tools on
     the z Systems architecture at
     <a class="link" href="http://www.ibm.com/developerworks/linux/linux390/development_documentation.html" target="_blank">http://www.ibm.com/developerworks/linux/linux390/development_documentation.html</a>.
    </p></li><li class="listitem "><p>
     You can find general information about Kexec at
     <a class="link" href="http://www.ibm.com/developerworks/linux/library/l-kexec.html" target="_blank">http://www.ibm.com/developerworks/linux/library/l-kexec.html</a>
     . Might be slightly outdated.
    </p></li><li class="listitem "><p>
     For more details on Kdump specific to <span class="productname"><span class="phrase">openSUSE Leap</span></span>, see
     <a class="link" href="http://ftp.suse.com/pub/people/tiwai/kdump-training/kdump-training.pdf" target="_blank">http://ftp.suse.com/pub/people/tiwai/kdump-training/kdump-training.pdf</a>
     .
    </p></li><li class="listitem "><p>
     An in-depth description of Kdump internals can be found at
     <a class="link" href="http://lse.sourceforge.net/kdump/documentation/ols2oo5-kdump-paper.pdf" target="_blank">http://lse.sourceforge.net/kdump/documentation/ols2oo5-kdump-paper.pdf</a>
     .
    </p></li></ul></div><p>
   For more details on <code class="command">crash</code> dump analysis and
   debugging tools, use the following resources:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     In addition to the info page of GDB (<code class="command">info gdb</code>),
     there are printable guides at
     <a class="link" href="http://sourceware.org/gdb/documentation/" target="_blank">http://sourceware.org/gdb/documentation/</a> .
    </p></li><li class="listitem "><p>
     A white paper with a comprehensive description of the crash utility
     usage can be found at
     <a class="link" href="http://people.redhat.com/anderson/crash_whitepaper/" target="_blank">http://people.redhat.com/anderson/crash_whitepaper/</a>.
    </p></li><li class="listitem "><p>
     The crash utility also features a comprehensive online help. Use
     <code class="command">help</code> <em class="replaceable ">COMMAND</em> to display
     the online help for <code class="command">command</code>.
    </p></li><li class="listitem "><p>
     If you have the necessary Perl skills, you can use Alicia to make the
     debugging easier. This Perl-based front-end to the crash utility can be
     found at <a class="link" href="http://alicia.sourceforge.net/" target="_blank">http://alicia.sourceforge.net/</a> .
    </p></li><li class="listitem "><p>
     If you prefer to use Python instead, you should install Pykdump. This
     package helps you control GDB through Python scripts and can be
     downloaded from <a class="link" href="http://sf.net/projects/pykdump" target="_blank">http://sf.net/projects/pykdump</a> .
    </p></li><li class="listitem "><p>
     A very comprehensive overview of the Linux kernel internals is given in
     <em class="citetitle ">Understanding the Linux Kernel</em> by Daniel P.
     Bovet and Marco Cesati (ISBN 978-0-596-00565-8).
    </p></li></ul></div></div></div></div><div class="page-bottom"><div id="_bottom-navigation"><a class="nav-link" href="part.tuning.ptp.html"><span class="next-icon">→</span><span class="nav-label"><span class="number">Part VII </span>Synchronized Clocks with Precision Time Protocol</span></a><a class="nav-link" href="cha.tuning.tracing.html"><span class="prev-icon">←</span><span class="nav-label"><span class="number">Chapter 16 </span>Tracing Tools</span></a></div><div id="_share-print"><div class="online-contents share"><strong>Share this page: </strong><span class="share-buttons"><span id="_share-fb" class="bottom-button">Facebook</span><span class="spacer"> • </span><span id="_share-gp" class="bottom-button">Google+</span><span class="spacer"> • </span><span id="_share-tw" class="bottom-button">Twitter</span></span></div><div class="print"><span id="_print-button" class="bottom-button">Print this page</span></div><div class="clearme"></div></div></div></div><div id="_inward"></div></div><div id="_footer-wrap"><div id="_footer"><p>©
        2018 
        SUSE</p></div></div></body></html>