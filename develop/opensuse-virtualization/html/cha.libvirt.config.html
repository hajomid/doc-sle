<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Configuring Virtual Machines | Virtualization Guide | openSUSE Leap 42.3</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /><link rel="stylesheet" type="text/css" href="static/css/style.css" /><link rel="stylesheet" type="text/css" href="static/css/highlight.css" /><link rel="stylesheet" type="text/css" href="static/css/brand.css" /><meta name="generator" content="DAPS 2.4.0 using openSUSE XSL Stylesheets 2.0.8 (based on DocBook XSL Stylesheets 1.78.1) - chunked" /><meta name="product-name" content="openSUSE Leap" /><meta name="product-number" content="42.3" /><meta name="book-title" content="Virtualization Guide" /><meta name="chapter-title" content="Chapter 13. Configuring Virtual Machines" /><meta name="description" content="Virtual Machine Manager's Details view offers in-depth information about the VM Guest's complete configuration and hardware equipment. Using this view, you can also change the guest configuration or add and modify virtual hardware. To access this view, open the guest's console in Virtual Machine Manager and either choose ViewDetails from the menu, or click Show virtual hardware details in the toolbar." /><meta name="tracker-url" content="https://bugzilla.opensuse.org/enter_bug.cgi" /><meta name="tracker-type" content="bsc" /><meta name="tracker-bsc-assignee" content="fs@suse.com" /><meta name="tracker-bsc-component" content="Documentation" /><meta name="tracker-bsc-product" content="openSUSE Distribution" /><meta name="tracker-bsc-version" content="Leap 42.2" /><link rel="home" href="index.html" title="openSUSE Leap Documentation" /><link rel="up" href="part.virt.libvirt.html" title="Part II. Managing Virtual Machines with libvirt" /><link rel="prev" href="cha.libvirt.networks.html" title="Chapter 12. Managing Networks" /><link rel="next" href="part.virt.common.html" title="Part III. Hypervisor-Independent Features" /><script type="text/javascript">

var protocol = window.location.protocol.toLowerCase();
if ( protocol != 'file:' ) {
  var agent = navigator.userAgent.toLowerCase();
  var wanted = ( protocol == 'https:') ? 'https' : 'http';
  var file = 'fonts.css';
  document.write('<link rel="stylesheet" type="text/css" href="' + wanted + '://static.opensuse.org/fonts/'+ file +'"></link>');
}
else {
   document.write('<link rel="stylesheet" type="text/css" href="static/css/fonts-onlylocal.css"></link>');
}

</script><noscript><link rel="stylesheet" type="text/css" href="http://static.opensuse.org/fonts/fonts.css" /></noscript><script src="static/js/jquery-1.10.2.min.js" type="text/javascript"></script><script src="static/js/script.js" type="text/javascript"></script><script src="static/js/highlight.min.js" type="text/javascript"></script><script>

$(document).ready(function() {
  $('.verbatim-wrap.highlight').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
hljs.configure({
  useBR: false
});

</script></head><body class="draft offline js-off"><div id="_outer-wrap"><div id="_white-bg"><div id="_header"><div id="_logo"><img src="static/images/logo.png" alt="Logo" /></div><div class="crumbs"><a class="book-link" href="index.html" title="openSUSE Leap Documentation"><span class="book-icon">openSUSE Leap Documentation</span></a><span> › </span><a class="crumb" href="book.virt.html">Virtualization Guide</a><span> › </span><a class="crumb" href="part.virt.libvirt.html">Managing Virtual Machines with libvirt</a><span> › </span><a class="crumb" href="cha.libvirt.config.html">Configuring Virtual Machines</a></div><div class="clearme"></div></div></div><div id="_toolbar-wrap"><div id="_toolbar"><div id="_toc-area" class="inactive"><a id="_toc-area-button" class="tool" title="Contents" accesskey="c" href="index.html"><span class="tool-spacer"><span class="toc-icon">Contents</span><span class="clearme"></span></span><span class="tool-label">Contents</span></a><div class="active-contents bubble-corner"></div><div class="active-contents bubble"><div class="bubble-container"><h6>Virtualization Guide</h6><div id="_bubble-toc"><ol><li class="inactive"><a href="cha.kvm.html"><span class="number"> </span><span class="name">About This Manual</span></a></li><li class="inactive"><a href="part.virt.intro.html"><span class="number">I </span><span class="name">Introduction</span></a><ol><li class="inactive"><a href="chap.virtualization.introduction.html"><span class="number">1 </span><span class="name">Virtualization Technology</span></a></li><li class="inactive"><a href="cha.xen.basics.html"><span class="number">2 </span><span class="name">Introduction to Xen Virtualization</span></a></li><li class="inactive"><a href="cha.kvm.intro.html"><span class="number">3 </span><span class="name">Introduction to KVM Virtualization</span></a></li><li class="inactive"><a href="cha.containers.intro.html"><span class="number">4 </span><span class="name">Introduction to Linux Containers</span></a></li><li class="inactive"><a href="cha.tools.intro.html"><span class="number">5 </span><span class="name">Virtualization Tools</span></a></li><li class="inactive"><a href="cha.vt.installation.html"><span class="number">6 </span><span class="name">Installation of Virtualization Components</span></a></li></ol></li><li class="inactive"><a href="part.virt.libvirt.html"><span class="number">II </span><span class="name">Managing Virtual Machines with <code class="systemitem">libvirt</code></span></a><ol><li class="inactive"><a href="cha.libvirt.overview.html"><span class="number">7 </span><span class="name">Starting and Stopping <code class="systemitem">libvirtd</code></span></a></li><li class="inactive"><a href="cha.kvm.inst.html"><span class="number">8 </span><span class="name">Guest Installation</span></a></li><li class="inactive"><a href="cha.libvirt.managing.html"><span class="number">9 </span><span class="name">Basic VM Guest Management</span></a></li><li class="inactive"><a href="cha.libvirt.connect.html"><span class="number">10 </span><span class="name">Connecting and Authorizing</span></a></li><li class="inactive"><a href="cha.libvirt.storage.html"><span class="number">11 </span><span class="name">Managing Storage</span></a></li><li class="inactive"><a href="cha.libvirt.networks.html"><span class="number">12 </span><span class="name">Managing Networks</span></a></li><li class="inactive"><a href="cha.libvirt.config.html"><span class="number">13 </span><span class="name">Configuring Virtual Machines</span></a></li></ol></li><li class="inactive"><a href="part.virt.common.html"><span class="number">III </span><span class="name">Hypervisor-Independent Features</span></a><ol><li class="inactive"><a href="cha.cachemodes.html"><span class="number">14 </span><span class="name">Disk Cache Modes</span></a></li><li class="inactive"><a href="sec.kvm.managing.clock.html"><span class="number">15 </span><span class="name">VM Guest Clock Settings</span></a></li><li class="inactive"><a href="chap.guestfs.html"><span class="number">16 </span><span class="name">libguestfs</span></a></li></ol></li><li class="inactive"><a href="part.virt.xen.html"><span class="number">IV </span><span class="name">Managing Virtual Machines with Xen</span></a><ol><li class="inactive"><a href="cha.xen.vhost.html"><span class="number">17 </span><span class="name">Setting Up a Virtual Machine Host</span></a></li><li class="inactive"><a href="cha.xen.network.html"><span class="number">18 </span><span class="name">Virtual Networking</span></a></li><li class="inactive"><a href="cha.xen.manage.html"><span class="number">19 </span><span class="name">Managing a Virtualization Environment</span></a></li><li class="inactive"><a href="cha.xen.vbd.html"><span class="number">20 </span><span class="name">Block Devices in Xen</span></a></li><li class="inactive"><a href="cha.xen.config.html"><span class="number">21 </span><span class="name">Virtualization: Configuration Options and Settings</span></a></li><li class="inactive"><a href="cha.xen.admin.html"><span class="number">22 </span><span class="name">Administrative Tasks</span></a></li><li class="inactive"><a href="cha.xen.xenstore.html"><span class="number">23 </span><span class="name">XenStore: Configuration Database Shared between Domains</span></a></li><li class="inactive"><a href="cha.xen.ha.html"><span class="number">24 </span><span class="name">Xen as a High-Availability Virtualization Host</span></a></li></ol></li><li class="inactive"><a href="part.virt.qemu.html"><span class="number">V </span><span class="name">Managing Virtual Machines with QEMU</span></a><ol><li class="inactive"><a href="cha.qemu.overview.html"><span class="number">25 </span><span class="name">QEMU Overview</span></a></li><li class="inactive"><a href="cha.qemu.host.html"><span class="number">26 </span><span class="name">Setting Up a KVM VM Host Server</span></a></li><li class="inactive"><a href="cha.qemu.guest_inst.html"><span class="number">27 </span><span class="name">Guest Installation</span></a></li><li class="inactive"><a href="cha.qemu.running.html"><span class="number">28 </span><span class="name">Running Virtual Machines with qemu-system-ARCH</span></a></li><li class="inactive"><a href="cha.qemu.monitor.html"><span class="number">29 </span><span class="name">Virtual Machine Administration Using QEMU Monitor</span></a></li></ol></li><li class="inactive"><a href="part.virt.lxc.html"><span class="number">VI </span><span class="name">Managing Virtual Machines with LXC</span></a><ol><li class="inactive"><a href="cha.lxc.html"><span class="number">30 </span><span class="name">Linux Containers</span></a></li><li class="inactive"><a href="cha.lxc2libvirt.html"><span class="number">31 </span><span class="name">Migration from LXC to <code class="systemitem">libvirt-lxc</code></span></a></li></ol></li><li class="inactive"><a href="gloss.vt.glossary.html"><span class="number"> </span><span class="name">Glossary</span></a></li><li class="inactive"><a href="app.kvm.html"><span class="number">A </span><span class="name">Appendix</span></a></li><li class="inactive"><a href="cha.xmtoxl.html"><span class="number">B </span><span class="name">XM, XL Toolstacks and Libvirt framework</span></a></li><li class="inactive"><a href="bk06apc.html"><span class="number">C </span><span class="name">GNU Licenses</span></a></li></ol></div><div class="clearme"></div></div></div></div><div id="_nav-area" class="inactive"><div class="tool"><span class="nav-inner"><span class="tool-label">Navigation</span><a accesskey="p" class="tool-spacer" title="Chapter 12. Managing Networks" href="cha.libvirt.networks.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Part III. Hypervisor-Independent Features" href="part.virt.common.html"><span class="next-icon">→</span></a></span></div></div></div></div><div id="_fixed-header-wrap" class="inactive"><div id="_fixed-header"><div class="crumbs"><a class="book-link" href="index.html" title="openSUSE Leap Documentation"><span class="book-icon">openSUSE Leap Documentation</span></a><span> › </span><a class="crumb" href="book.virt.html">Virtualization Guide</a><span> › </span><a class="crumb" href="part.virt.libvirt.html">Managing Virtual Machines with libvirt</a><span> › </span><a class="crumb" href="cha.libvirt.config.html">Configuring Virtual Machines</a></div><div class="buttons"><a class="top-button button" href="#">Top</a><div class="button"><a accesskey="p" class="tool-spacer" title="Chapter 12. Managing Networks" href="cha.libvirt.networks.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Part III. Hypervisor-Independent Features" href="part.virt.common.html"><span class="next-icon">→</span></a></div><div class="clearme"></div></div><div class="clearme"></div></div></div><div id="_content" class="draft "><div class="documentation"><div class="chapter " id="cha.libvirt.config"><div class="titlepage"><div><div class="version-info">Applies to  <span class="productname"><span class="productname"><span class="phrase">openSUSE Leap</span></span></span> <span class="productnumber"><span class="productnumber"><span class="phrase">42.3</span></span></span></div><div><h2 class="title"><span class="number">13 </span><span class="name">Configuring Virtual Machines</span> </h2><div class="doc-status"><ul><li><span class="ds-label">Filename: </span>libvirt_configuration.xml</li><li><span class="ds-label">ID: </span>cha.libvirt.config</li></ul></div></div><div><div class="abstract"><div class="abstract-title-wrap"><h6 class="abstract-title">Abstract<a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764859120">#</a></h6></div><p>
    Virtual Machine Manager's <span class="guimenu">Details</span> view offers in-depth information
    about the VM Guest's complete configuration and hardware equipment.
    Using this view, you can also change the guest configuration or add and
    modify virtual hardware. To access this view, open the guest's console
    in Virtual Machine Manager and either choose <span class="guimenu">View</span> › <span class="guimenu">Details</span> from the menu, or click
    <span class="guimenu">Show virtual hardware details</span> in the toolbar.
   </p></div></div></div></div><div class="line"><div class="toc"><dl><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.machine_setup"><span class="number">13.1 </span><span class="name">Machine Setup</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.storage"><span class="number">13.2 </span><span class="name">Storage</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.controllers"><span class="number">13.3 </span><span class="name">Controllers</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.networking"><span class="number">13.4 </span><span class="name">Networking</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.tablet"><span class="number">13.5 </span><span class="name">Enabling Seamless and Synchronized Mouse Pointer Movement</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.cdrom"><span class="number">13.6 </span><span class="name">Adding a CD/DVD-ROM Device with Virtual Machine Manager</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.floppy"><span class="number">13.7 </span><span class="name">Adding a Floppy Device with Virtual Machine Manager</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.cdrom.media_change"><span class="number">13.8 </span><span class="name">Ejecting and Changing Floppy or CD/DVD-ROM Media with Virtual Machine Manager</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.mahcinetype.virsh"><span class="number">13.9 </span><span class="name">Changing the Machine Type with <code class="command">virsh</code></span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.pci"><span class="number">13.10 </span><span class="name">Assigning a Host PCI Device to a VM Guest</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.usb"><span class="number">13.11 </span><span class="name">Assigning a Host USB Device to a VM Guest</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.io"><span class="number">13.12 </span><span class="name">Adding SR-IOV Devices</span></a></span></dt><dt><span class="sect1"><a href="cha.libvirt.config.html#sec.libvirt.config.direct"><span class="number">13.13 </span><span class="name">Using Macvtap to Share VM Host Server Network Interfaces</span></a></span></dt></dl></div></div><div class="figure" id="idm139774764854320"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_details.png"><img src="images/libvirt_vmm_details.png" width="" alt="Details View of a VM Guest" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.1: </span><span class="name"><span class="guimenu">Details</span> View of a VM Guest </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764854320">#</a></h6></div></div><p>
  The left panel of the window lists VM Guest overview and already
  installed hardware. After clicking an item in the list, you can access its
  detailed settings in the details view. You can change the hardware
  parameters to match your needs, then click <span class="guimenu">Apply</span> to
  confirm them. Some changes take effect immediately, while others need a
  reboot of the machine—and <code class="systemitem">virt-manager</code>
  warns you about that fact.
 </p><p>
  To remove installed hardware from a VM Guest, select the appropriate list
  entry in the left panel and then click <span class="guimenu">Remove</span> in the
  bottom right of the window.
 </p><p>
  To add new hardware, click <span class="guimenu">Add Hardware</span> below the left
  panel, then select the type of the hardware you want to add in the
  <span class="guimenu">Add New Virtual Hardware</span> window. Modify its parameters
  and confirm with <span class="guimenu">Finish</span>.
 </p><p>
  The following sections describe configuration options for the specific
  hardware type <span class="emphasis"><em>being added</em></span>. They do not focus on
  modifying an existing piece of hardware as the options are identical.
 </p><div class="sect1 " id="sec.libvirt.config.machine_setup"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.machine_setup"><span class="number">13.1 </span><span class="name">Machine Setup</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.machine_setup">#</a></h2></div></div></div><p>
   This section describes the setup of the virtualized processor and memory
   hardware. These components are vital to a VM Guest, therefore you cannot
   remove them. It also shows how to view the overview and performance
   information, and how to change boot parameters.
  </p><div class="sect2 " id="idm139774764841472"><div class="titlepage"><div><div><h3 class="title" id="idm139774764841472"><span class="number">13.1.1 </span><span class="name">Overview</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764841472">#</a></h3></div></div></div><p>
    <span class="guimenu">Overview</span> shows basic details about VM Guest and the
    hypervisor.
   </p><div class="figure" id="idm139774764839792"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_overview.png"><img src="images/libvirt_vmm_overview.png" width="" alt="Overview details" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.2: </span><span class="name">Overview details </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764839792">#</a></h6></div></div><p>
    <span class="guimenu">Name</span>, <span class="guimenu">Title</span>, and
    <span class="guimenu">Description</span> are editable and help you identify
    VM Guest in the <span class="guimenu">Virtual Machine Manager</span> list of
    machines.
   </p><div class="figure" id="idm139774764832512"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_desc.png"><img src="images/libvirt_vmm_desc.png" width="" alt="VM Guest Title and Description" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.3: </span><span class="name">VM Guest Title and Description </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764832512">#</a></h6></div></div><p>
    <span class="guimenu">UUID</span> shows the universally unique identifier of the
    virtual machine, while <span class="guimenu">Status</span> shows its current
    status—<span class="guimenu">Running</span>, <span class="guimenu">Paused</span>, or
    <span class="guimenu">Shutoff</span>.
   </p><p>
    The <span class="guimenu">Hypervisor Details</span> section shows the hypervisor
    type, CPU architecture, used emulator, and chipset type. None of the
    hypervisor parameters can be changed.
   </p></div><div class="sect2 " id="idm139774764823552"><div class="titlepage"><div><div><h3 class="title" id="idm139774764823552"><span class="number">13.1.2 </span><span class="name">Performance</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764823552">#</a></h3></div></div></div><p>
    <span class="guimenu">Performance</span> shows regularly updated charts of CPU and
    memory usage, and disk and network I/O.
   </p><div class="figure" id="idm139774764821840"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_performance.png"><img src="images/libvirt_vmm_performance.png" width="" alt="Performance" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.4: </span><span class="name">Performance </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764821840">#</a></h6></div></div><div id="idm139774764816816" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Enabling Disabled Charts</h6><p>
     Not all the charts in the <span class="guimenu">Graph</span> view are
     enabled by default. To enable these charts, go to
     <span class="guimenu">File</span> › <span class="guimenu">View
     Manager</span>, then select
     <span class="guimenu">Edit</span> › <span class="guimenu">Preferences</span> › <span class="guimenu">Polling</span>, and check the
     charts that you want to see regularly updated.
    </p></div><div class="figure" id="idm139774764812704"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_polling_charts.png"><img src="images/libvirt_vmm_polling_charts.png" width="" alt="Statistics Charts" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.5: </span><span class="name">Statistics Charts </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764812704">#</a></h6></div></div></div><div class="sect2 " id="idm139774764807520"><div class="titlepage"><div><div><h3 class="title" id="idm139774764807520"><span class="number">13.1.3 </span><span class="name">Processor</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764807520">#</a></h3></div></div></div><p>
    <span class="guimenu">Processor</span> includes detailed information about
    VM Guest processor configuration.
   </p><div class="figure" id="idm139774764805824"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_processor.png"><img src="images/libvirt_vmm_processor.png" width="" alt="Processor View" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.6: </span><span class="name">Processor View </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764805824">#</a></h6></div></div><p>
    In the <span class="guimenu">CPUs</span> section, you can configure several
    parameters related to the number of allocated CPUs.
   </p><div class="variablelist "><dl class="variablelist"><dt id="idm139774764799536"><span class="term "><span class="guimenu">Logical host CPUs</span>
     </span></dt><dd><p>
       The real number of CPUs installed on VM Host Server.
      </p></dd><dt id="idm139774764797408"><span class="term "><span class="guimenu">Current allocation</span>
     </span></dt><dd><p>
       The number of currently allocated CPUs. You can hotplug more CPUs by
       increasing this value up to the <span class="guimenu">Maximum allocation</span>
       value.
      </p></dd><dt id="idm139774764794784"><span class="term "><span class="guimenu">Maximum allocation</span>
     </span></dt><dd><p>
       Maximum number of allocable CPUs for the current session. Any change
       to this value will take effect after the next VM Guest reboot.
      </p></dd></dl></div><p>
    The <span class="guimenu">Configuration</span> section lets you configure the CPU
    model and topology.
   </p><p>
    When activated, the <span class="guimenu">Copy host CPU configuration</span>
    option uses the host CPU model for VM Guest. Otherwise you need to
    specify the CPU model from the drop-down box.
   </p><p>
    After you activate <span class="guimenu">Manually set CPU topology</span>, you can
    specify a custom number of sockets, cores and threads for the CPU.
   </p></div><div class="sect2 " id="idm139774764789264"><div class="titlepage"><div><div><h3 class="title" id="idm139774764789264"><span class="number">13.1.4 </span><span class="name">Memory</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764789264">#</a></h3></div></div></div><p>
    <span class="guimenu">Memory</span> contains information about the memory that is
    available to VM Guest.
   </p><div class="figure" id="idm139774764787568"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_memory.png"><img src="images/libvirt_vmm_memory.png" width="" alt="Memory View" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.7: </span><span class="name">Memory View </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764787568">#</a></h6></div></div><div class="variablelist "><dl class="variablelist"><dt id="idm139774764782288"><span class="term "><span class="guimenu">Total host memory</span>
     </span></dt><dd><p>
       Total amount of memory installed on VM Host Server.
      </p></dd><dt id="idm139774764780160"><span class="term "><span class="guimenu">Current allocation</span>
     </span></dt><dd><p>
       The amount of memory currently available to VM Guest. You can
       hotplug more memory by increasing this value up to the value of
       <span class="guimenu">Maximum allocation</span>.
      </p></dd><dt id="idm139774764777504"><span class="term "><span class="guimenu">Maximum allocation</span>
     </span></dt><dd><p>
       The maximum value to which you can hotplug the currently available
       memory. Any change to this value will take effect after the next
       VM Guest reboot.
      </p></dd></dl></div></div><div class="sect2 " id="idm139774764774944"><div class="titlepage"><div><div><h3 class="title" id="idm139774764774944"><span class="number">13.1.5 </span><span class="name">Boot Options</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764774944">#</a></h3></div></div></div><p>
    <span class="guimenu">Boot Options</span> introduces options affecting the
    VM Guest boot process.
   </p><div class="figure" id="idm139774764773264"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_boot.png"><img src="images/libvirt_vmm_boot.png" width="" alt="Boot Options" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.8: </span><span class="name">Boot Options </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764773264">#</a></h6></div></div><p>
    In the <span class="guimenu">Autostart</span> section, you can specify whether the
    virtual machine should automatically start during the VM Host Server boot phase.
   </p><p>
    In the <span class="guimenu">Boot device order</span>, activate the devices that
    will be used for booting VM Guest. You can change their order with the
    up and down arrow buttons on the right side of the list. To choose
    from a list of bootable devices on VM Guest start, activate
    <span class="guimenu">Enable boot menu</span>.
   </p><p>
    To boot a different kernel than the one on the boot device, activate
    <span class="guimenu">Enable direct kernel boot</span> and specify the paths to the
    alternative kernel and initrd placed on the VM Host Server file system. You
    can also specify kernel arguments that will be passed to the loaded
    kernel.
   </p></div></div><div class="sect1 " id="sec.libvirt.config.storage"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.storage"><span class="number">13.2 </span><span class="name">Storage</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.storage">#</a></h2></div></div></div><p>
   This section gives you a detailed description of configuration options for
   storage devices. It includes both hard disks and removable media, such as
   USB or CD-ROM drives.
  </p><div class="procedure " id="idm139774764762368"><div class="procedure-title-wrap"><h6 class="procedure-title"><span class="number">Procedure 13.1: </span><span class="name">Adding a New Storage Device </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764762368">#</a></h6></div><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Click <span class="guimenu">Add Hardware</span> below the left panel, then select
     <span class="guimenu">Storage</span> from the <span class="guimenu">Add New Virtual
     Hardware</span> window.
    </p><div class="figure" id="idm139774764759536"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_storage1.png"><img src="images/libvirt_vmm_storage1.png" width="" alt="Add a New Storage" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.9: </span><span class="name">Add a New Storage </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764759536">#</a></h6></div></div></li><li class="step "><p>
     To create a <code class="literal">qcow2</code> disk image in the default location,
     activate <span class="guimenu">Create a disk image for the virtual
     machine</span> and specify its size in gigabytes.
    </p><p>
     To gain more control over the disk image creation, activate
     <span class="guimenu">Select or create custom storage</span> and click
     <span class="guimenu">Manage</span> to manage storage pools and images.
     The window <span class="guimenu">Choose Storage Volume</span> opens which has almost
     identical functionality as the <span class="guimenu">Storage</span> tab
     described in <a class="xref" href="cha.libvirt.storage.html#sec.libvirt.storage.vmm" title="11.1. Managing Storage with Virtual Machine Manager">Section 11.1, “Managing Storage with Virtual Machine Manager”</a>.
    </p><div id="idm139774764749680" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Supported Storage Formats</h6><p>
      SUSE only supports the following storage formats:
      <code class="literal">raw</code>, <code class="literal">qcow2</code>, and
      <code class="literal">qed</code>.
     </p></div></li><li class="step "><p>
     After you manage to create and specify the disk image file, specify the
     <span class="guimenu">Device type</span>. It can be one of the following options:
    </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
       <span class="guimenu">Disk device</span>
      </p></li><li class="listitem "><p>
       <span class="guimenu">CDROM device</span>: Does not allow using <span class="guimenu">Create a
       disk image for the virtual machine</span>.
      </p></li><li class="listitem "><p>
       <span class="guimenu">Floppy device</span>: Does not allow using <span class="guimenu">Create a
       disk image for the virtual machine</span>.
      </p></li><li class="listitem "><p>
       <span class="guimenu">LUN Passthrough</span>: Required to use an existing SCSI
       storage directly without adding it into a storage pool.
      </p></li></ul></div></li><li class="step "><p>
     Select the <span class="guimenu">Bus type</span> for your device. The list of
     available options depends on the device type you selected in the
     previous step. The types based on <span class="guimenu">VirtIO</span> use
     paravirtualized drivers.
    </p></li><li class="step "><p>
     In the <span class="guimenu">Advanced options</span> section, select the
     preferred <span class="guimenu">Cache mode</span>. For more information on cache
     modes, see <a class="xref" href="cha.cachemodes.html" title="Chapter 14. Disk Cache Modes">Chapter 14, <em>Disk Cache Modes</em></a>.
    </p></li><li class="step "><p>
     Confirm your settings with <span class="guimenu">Finish</span>. A new storage
     device appears in the left panel.
    </p></li></ol></div></div></div><div class="sect1 " id="sec.libvirt.config.controllers"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.controllers"><span class="number">13.3 </span><span class="name">Controllers</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.controllers">#</a></h2></div></div></div><p>
   This section focuses on adding and configuring new controllers.
  </p><div class="procedure " id="idm139774764730640"><div class="procedure-title-wrap"><h6 class="procedure-title"><span class="number">Procedure 13.2: </span><span class="name">Adding a New Controller </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764730640">#</a></h6></div><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Click <span class="guimenu">Add Hardware</span> below the left panel, then select
     <span class="guimenu">Controller</span> from the <span class="guimenu">Add New Virtual
     Hardware</span> window.
    </p><div class="figure" id="idm139774764727808"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_controller.png"><img src="images/libvirt_vmm_controller.png" width="" alt="Add a New Controller" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.10: </span><span class="name">Add a New Controller </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764727808">#</a></h6></div></div></li><li class="step "><p>
     Select the type of the controller. You can choose from
     <span class="guimenu">IDE</span>, <span class="guimenu">Floppy</span>,
     <span class="guimenu">SCSI</span>, <span class="guimenu">SATA</span>, <span class="guimenu">VirtIO
     Serial</span> (paravirtualized), <span class="guimenu">USB</span>, or
     <span class="guimenu">CCID</span> (smart card devices).
    </p></li><li class="step "><p>
     Optionally, in the case of a USB or SCSI controller, select a controller
     model.
    </p></li><li class="step "><p>
     Confirm your settings with <span class="guimenu">Finish</span>. A new controller
     appears in the left panel.
    </p></li></ol></div></div></div><div class="sect1 " id="sec.libvirt.config.networking"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.networking"><span class="number">13.4 </span><span class="name">Networking</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.networking">#</a></h2></div></div></div><p>
   This section describes how to add and configure new network devices.
  </p><div class="procedure " id="idm139774764714080"><div class="procedure-title-wrap"><h6 class="procedure-title"><span class="number">Procedure 13.3: </span><span class="name">Adding a New Network Device </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764714080">#</a></h6></div><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Click <span class="guimenu">Add Hardware</span> below the left panel, then select
     <span class="guimenu">Network</span> from the <span class="guimenu">Add New Virtual
     Hardware</span> window.
    </p><div class="figure" id="idm139774764711248"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/libvirt_vmm_network.png"><img src="images/libvirt_vmm_network.png" width="" alt="Add a New Controller" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.11: </span><span class="name">Add a New Controller </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764711248">#</a></h6></div></div></li><li class="step "><p>
     From the <span class="guimenu">Network source</span> list, select the source for
     the network connection. The list includes VM Host Server's available physical
     network interfaces, network bridges, or network bonds. You can also
     assign the VM Guest to an already defined virtual network. See
     <a class="xref" href="cha.libvirt.networks.html" title="Chapter 12. Managing Networks">Chapter 12, <em>Managing Networks</em></a> for more information on setting
     up virtual networks with Virtual Machine Manager.
    </p></li><li class="step "><p>
     Specify a <span class="guimenu">MAC address</span> for the network device. While
     Virtual Machine Manager pre-fills a random value for your convenience, it is recommended
     to supply a MAC address appropriate for your network environment to
     avoid network conflicts.
    </p></li><li class="step "><p>
     Select a device model from the list. You can either leave the
     <span class="guimenu">Hypervisor default</span>, or specify one of
     <span class="guimenu">e1000</span>,
     <span class="guimenu">rtl8139</span>, or <span class="guimenu">virtio</span> models. Note
     that <span class="emphasis"><em>virtio</em></span> uses paravirtualized drivers.
    </p></li><li class="step "><p>
     Confirm your settings with <span class="guimenu">Finish</span>. A new network
     device appears in the left panel.
    </p></li></ol></div></div></div><div class="sect1 " id="sec.libvirt.config.tablet"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.tablet"><span class="number">13.5 </span><span class="name">Enabling Seamless and Synchronized Mouse Pointer Movement</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.tablet">#</a></h2></div></div></div><p>
   When you click within a VM Guest's console with the mouse, the pointer is
   captured by the console window and cannot be used outside the console
   unless it is explicitly released (by pressing <span class="keycap">Alt</span><span class="key-connector">–</span><span class="keycap">Ctrl</span>). To
   prevent the console from grabbing the key and to enable seamless pointer
   movement between host and guest instead, add a tablet to the VM Guest.
  </p><p>
   Adding a tablet has the additional advantage of synchronizing the mouse
   pointer movement between VM Host Server and VM Guest when using a graphical
   environment on the guest. With no tablet configured on the guest, you
   will often see two pointers with one dragging behind the other.
  </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Double-click a VM Guest entry in the Virtual Machine Manager to open its console and
     switch to the <span class="guimenu">Details</span> view with <span class="guimenu">View</span> › <span class="guimenu">Details</span>.
    </p></li><li class="step "><p>
     Click <span class="guimenu">Add Hardware</span> and choose
     <span class="guimenu">Input</span> and then <span class="guimenu">EvTouch USB Graphics
     Tablet</span> in the pop-up window. Proceed with
     <span class="guimenu">Finish</span>.
    </p></li><li class="step "><p>
     If the guest is running, you will
     be asked whether to enable the tablet after the next reboot. Confirm
     with <span class="guimenu">Yes</span>.
    </p></li><li class="step "><p>
     When you start or restart the VM Guest, the tablet becomes available in
     the VM Guest.
    </p></li></ol></div></div></div><div class="sect1 " id="sec.libvirt.config.cdrom"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.cdrom"><span class="number">13.6 </span><span class="name">Adding a CD/DVD-ROM Device with Virtual Machine Manager</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.cdrom">#</a></h2></div></div></div><p>
   KVM supports CD or DVD-ROMs in VM Guest either by directly accessing a
   physical drive on the VM Host Server or by accessing ISO images. To create an
   ISO image from an existing CD or DVD, use <code class="command">dd</code>:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> dd if=/dev/<em class="replaceable ">CD_DVD_DEVICE</em> of=my_distro.iso bs=2048</pre></div><p>
   To add a CD/DVD-ROM device to your VM Guest, proceed as follows:
  </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Double-click a VM Guest entry in the Virtual Machine Manager to open its console and
     switch to the <span class="guimenu">Details</span> view with <span class="guimenu">View</span> › <span class="guimenu">Details</span>.
    </p></li><li class="step "><p>
     Click <span class="guimenu">Add Hardware</span> and choose
     <span class="guimenu">Storage</span> in the pop-up window.
    </p></li><li class="step "><p>
     Change the <span class="guimenu">Device Type</span> to <span class="guimenu">IDE
     CDROM</span>.
    </p></li><li class="step "><p>
     Select <span class="guimenu">Select or create custom storage</span>.
    </p><ol type="a" class="substeps "><li class="step "><p>
       To assign the device to a physical medium, enter the path to the
       VM Host Server's CD/DVD-ROM device (for example,
       <code class="filename">/dev/cdrom</code>) next to
       <span class="guimenu">Manage</span>. Alternatively, use
       <span class="guimenu">Manage</span> to open a file browser and then
       click <span class="guimenu">Browse Local</span> to select the device. Assigning
       the device to a physical medium is only possible when the Virtual Machine Manager was
       started on the VM Host Server.
      </p></li><li class="step "><p>
       To assign the device to an existing image, click
       <span class="guimenu">Manage</span> to choose an image from a storage pool. If
       the Virtual Machine Manager was started on the VM Host Server, alternatively choose
       an image from another location on the file system by clicking
       <span class="guimenu">Browse Local</span>. Select an image and close the file
       browser with <span class="guimenu">Choose Volume</span>.
      </p></li></ol></li><li class="step "><p>
     Save the new virtualized device with <span class="guimenu">Finish</span>.
    </p></li><li class="step "><p>
     Reboot the VM Guest to make the new device
     available.<span class="phrase"> For more information, see
     <a class="xref" href="cha.libvirt.config.html#sec.libvirt.config.cdrom.media_change" title="13.8. Ejecting and Changing Floppy or CD/DVD-ROM Media with Virtual Machine Manager">Section 13.8, “Ejecting and Changing Floppy or CD/DVD-ROM Media with Virtual Machine Manager”</a>.</span>
    </p></li></ol></div></div></div><div class="sect1 " id="sec.libvirt.config.floppy"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.floppy"><span class="number">13.7 </span><span class="name">Adding a Floppy Device with Virtual Machine Manager</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.floppy">#</a></h2></div></div></div><p>
   Currently KVM only supports the use of floppy disk images—using a
   physical floppy drive is not supported. Create a floppy disk image from
   an existing floppy using <code class="command">dd</code>:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> dd if=/dev/fd0 of=/var/lib/libvirt/images/floppy.img</pre></div><p>
   To create an empty floppy disk image use one of the following commands:
  </p><div class="variablelist "><dl class="variablelist"><dt id="idm139774764657136"><span class="term ">Raw Image</span></dt><dd><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> dd if=/dev/zero of=/var/lib/libvirt/images/floppy.img bs=512 count=2880</pre></div></dd><dt id="idm139774764654704"><span class="term ">FAT Formatted Image</span></dt><dd><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> mkfs.msdos -C /var/lib/libvirt/images/floppy.img 1440</pre></div></dd></dl></div><p>
   To add a floppy device to your VM Guest, proceed as follows:
  </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Double-click a VM Guest entry in the Virtual Machine Manager to open its console and
     switch to the <span class="guimenu">Details</span> view with <span class="guimenu">View</span> › <span class="guimenu">Details</span>.
    </p></li><li class="step "><p>
     Click <span class="guimenu">Add Hardware</span> and choose
     <span class="guimenu">Storage</span> in the pop-up window.
    </p></li><li class="step "><p>
     Change the <span class="guimenu">Device Type</span> to <span class="guimenu">Floppy
     Disk</span>.
    </p></li><li class="step "><p>
     Choose <span class="guimenu">Select or create custom storage</span> and
     click <span class="guimenu">Manage</span> to choose an existing image from a
     storage pool. If Virtual Machine Manager was started on the VM Host Server,
     alternatively choose an image from another location on the file system
     by clicking <span class="guimenu">Browse Local</span>. Select an image and close
     the file browser with <span class="guimenu">Choose Volume</span>.
    </p></li><li class="step "><p>
     Save the new virtualized device with <span class="guimenu">Finish</span>.
    </p></li><li class="step "><p>
     Reboot the VM Guest to make the new device
     available.<span class="phrase"> For more information, see
     <a class="xref" href="cha.libvirt.config.html#sec.libvirt.config.cdrom.media_change" title="13.8. Ejecting and Changing Floppy or CD/DVD-ROM Media with Virtual Machine Manager">Section 13.8, “Ejecting and Changing Floppy or CD/DVD-ROM Media with Virtual Machine Manager”</a>.</span>
    </p></li></ol></div></div></div><div class="sect1 " id="sec.libvirt.config.cdrom.media_change"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.cdrom.media_change"><span class="number">13.8 </span><span class="name">Ejecting and Changing Floppy or CD/DVD-ROM Media with Virtual Machine Manager</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.cdrom.media_change">#</a></h2></div></div></div><p>
   Whether you are using the VM Host Server's physical CD/DVD-ROM
   device or an ISO/floppy image: Before you can change the media or image
   of an existing device in the VM Guest, you first need to
   <code class="literal">disconnect</code> the media from the guest.
  </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Double-click a VM Guest entry in the Virtual Machine Manager to open its console and
     switch to the <span class="guimenu">Details</span> view with <span class="guimenu">View</span> › <span class="guimenu">Details</span>.
    </p></li><li class="step "><p>
     Choose the Floppy or CD/DVD-ROM device and <span class="quote">“<span class="quote">eject</span>”</span> the
     medium by clicking <span class="guimenu">Disconnect</span>.
    </p></li><li class="step "><p>
     To <span class="quote">“<span class="quote">insert</span>”</span> a new medium, click <span class="guimenu">Connect</span>.
    </p><ol type="a" class="substeps "><li class="step "><p>
       If using the VM Host Server's physical CD/DVD-ROM device, first change the
       media in the device (this may require unmounting it on the VM Host Server
       before it can be ejected). Then choose <span class="guimenu">CD-ROM or
       DVD</span> and select the device from the drop-down box.
      </p></li><li class="step "><p>
       If you are using an ISO image, choose <span class="guimenu">ISO image
       Location</span> and select an image by clicking
       <span class="guimenu">Manage</span>. When connecting from a remote host, you may
       only choose images from existing storage pools.
      </p></li></ol></li><li class="step "><p>
     Click <span class="guimenu">OK</span> to finish. The new media can now be
     accessed in the VM Guest.
    </p></li></ol></div></div></div><div class="sect1 " id="sec.libvirt.config.mahcinetype.virsh"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.mahcinetype.virsh"><span class="number">13.9 </span><span class="name">Changing the Machine Type with <code class="command">virsh</code></span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.mahcinetype.virsh">#</a></h2></div></div></div><p>
   By default, when installing with the <code class="command">virt-install</code> tool, the machine type for VM Guest is
   <span class="emphasis"><em>pc-i440fx</em></span>. The machine type is stored in the
   VM Guest's xml configuration file in
   <code class="filename">/etc/libvirt/qemu/</code> in the tag <code class="sgmltag-element">type</code>:
  </p><div class="verbatim-wrap"><pre class="screen">&lt;type arch='x86_64' machine='pc-i440fx-2.3'&gt;hvm&lt;/type&gt;</pre></div><p>
   As an example, the following procedure shows how to change this value to the
   machine type <code class="literal">q35</code>. <code class="literal">q35</code> is an Intel*
   chipset. It includes <a class="xref" href="gloss.vt.glossary.html#gloss.vt.acronym.pcie" title="PCIe">PCIe</a>, supports up to
   12 USB ports, and has support for
   <a class="xref" href="gloss.vt.glossary.html#gloss.vt.acronym.sata" title="SATA">SATA</a> and
   <a class="xref" href="gloss.vt.glossary.html#gloss.vt.acronym.iommu" title="IOMMU">IOMMU</a>. IRQ routing has also
   been improved.
  </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
     Check whether your VM Guest is inactive:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> virsh list --inactive
Id    Name                           State
----------------------------------------------------
-     sles11                         shut off</pre></div></li><li class="step "><p>
     Edit the configuration for this VM Guest:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> virsh edit sles11</pre></div></li><li class="step "><p>
     Change the value of the
     <code class="sgmltag-attribute">machine</code>
     attribute:
    </p><div class="verbatim-wrap"><pre class="screen">&lt;type arch='x86_64' machine='pc-q35-2.0'&gt;hvm&lt;/type&gt;</pre></div></li><li class="step "><p>
     Restart the VM Guest.
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> <code class="command">virsh start sles11</code></pre></div></li><li class="step "><p>
     Check that the machine type has changed. Log in to the VM Guest as
     root and run the following command:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> <code class="command">dmidecode | grep Product</code>
Product Name: Standard PC (Q35 + ICH9, 2009)</pre></div></li></ol></div></div><div id="idm139774764603984" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Machine Type Update Recommendations</h6><p>
    Whenever the QEMU version on the host system is upgraded (for example,
    when upgrading the VM Host Server to a new service pack), upgrade the machine type
    of the VM Guests to the latest
    available version. To check, use the command <code class="command">qemu-system-x86_64 -M
    help</code> on the VM Host Server.
   </p><p>
    The default machine type <code class="literal">pc-i440fx</code>, for example, is
    regularly updated. If your VM Guest still runs with a machine type of
    <code class="literal">pc-i440fx-1.<em class="replaceable ">X</em></code>, an update
    to <code class="literal">pc-i440fx-2.<em class="replaceable ">X</em></code> is
    strongly recommended. This allows taking advantage of the most recent
    updates and corrections in machine definitions, and ensures
    better future compatibility.
   </p></div></div><div class="sect1 " id="sec.libvirt.config.pci"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.pci"><span class="number">13.10 </span><span class="name">Assigning a Host PCI Device to a VM Guest</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.pci">#</a></h2></div></div></div><p>
   You can directly assign host-PCI devices to guests (PCI pass-through).
   When the PCI device is assigned to one VM Guest, it cannot be used on
   the host or by another VM Guest unless it is re-assigned. A prerequisite for
   this feature is a VM Host Server configuration as described in
   <a class="xref" href="chap.virtualization.introduction.html#ann.vt.io.require" title="Important: Requirements for VFIO and SR-IOV">Important: Requirements for VFIO and SR-IOV</a>.
  </p><div class="sect2 " id="sec.libvirt.config.pci.vmm"><div class="titlepage"><div><div><h3 class="title" id="sec.libvirt.config.pci.vmm"><span class="number">13.10.1 </span><span class="name">Adding a PCI Device with Virtual Machine Manager</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.pci.vmm">#</a></h3></div></div></div><p>
    The following procedure describes how to add a PCI device to a VM Guest
    using Virtual Machine Manager:
   </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      Double-click a VM Guest entry in the Virtual Machine Manager to open its console and
      switch to the <span class="guimenu">Details</span> view with <span class="guimenu">View</span> › <span class="guimenu">Details</span>.
     </p></li><li class="step "><p>
      Click <span class="guimenu">Add Hardware</span> and choose the <span class="guimenu">PCI Host
      Device</span> category in the left panel. A list of available PCI
      devices appears in the right part of the window.
     </p><div class="figure" id="idm139774764590112"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/virt_add_pcidevice.png"><img src="images/virt_add_pcidevice.png" width="" alt="Adding a PCI Device" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.12: </span><span class="name">Adding a PCI Device </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764590112">#</a></h6></div></div></li><li class="step "><p>
      From the list of available PCI devices, choose the one you want to
      pass to the guest. Confirm with <span class="guimenu">Finish</span>.
     </p></li></ol></div></div><div id="idm139774764583360" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Assigning a PCI Device Requires a VM Guest Shutdown</h6><p>
     Although it is possible to assign a PCI device to a running VM Guest
     as described above, the device will not become available until you shut
     down the VM Guest and reboot it afterward.
    </p></div></div><div class="sect2 " id="sec.libvirt.config.pci.virsh"><div class="titlepage"><div><div><h3 class="title" id="sec.libvirt.config.pci.virsh"><span class="number">13.10.2 </span><span class="name">Adding a PCI Device with <code class="command">virsh</code></span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.pci.virsh">#</a></h3></div></div></div><p>
    To assign a PCI device to VM Guest with <code class="command">virsh</code>,
    follow these steps:
   </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      Identify the host PCI device to assign to the guest. In the following
      example, we are assigning a DEC network card to the guest:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> <code class="command">lspci -nn</code>
[...]
03:07.0 Ethernet controller [0200]: Digital Equipment Corporation DECchip \
21140 [FasterNet] [1011:0009] (rev 22)
[...]</pre></div><p>
      Note down the device ID (<code class="literal">03:07.0</code> in this case).
     </p></li><li class="step "><p>
      Gather detailed information about the device using <code class="command">virsh
      nodedev-dumpxml <em class="replaceable ">ID</em></code>. To get the
      <em class="replaceable ">ID</em>, you need to replace colon and period in
      the device ID (<code class="literal">03:07.0</code>) with underscore and prefix
      the result with <span class="quote">“<span class="quote">pci_0000_</span>”</span>
      (<code class="literal">pci_0000_03_07_0</code>).
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>virsh nodedev-dumpxml pci_0000_03_07_0
&lt;device&gt;
  &lt;name&gt;pci_0000_03_07_0&lt;/name&gt;
  &lt;path&gt;/sys/devices/pci0000:00/0000:00:14.4/0000:03:07.0&lt;/path&gt;
  &lt;parent&gt;pci_0000_00_14_4&lt;/parent&gt;
  &lt;driver&gt;
    &lt;name&gt;tulip&lt;/name&gt;
  &lt;/driver&gt;
  &lt;capability type='pci'&gt;
    <span class="bold"><strong>&lt;domain&gt;0&lt;/domain&gt;
    &lt;bus&gt;3&lt;/bus&gt;
    &lt;slot&gt;7&lt;/slot&gt;
    &lt;function&gt;0&lt;/function&gt;</strong></span>
    &lt;product id='0x0009'&gt;DECchip 21140 [FasterNet]&lt;/product&gt;
    &lt;vendor id='0x1011'&gt;Digital Equipment Corporation&lt;/vendor&gt;
    &lt;numa node='0'/&gt;
  &lt;/capability&gt;
&lt;/device&gt;</pre></div><p>
      Note down the values for domain, bus, and function.
     </p></li><li class="step "><p>
      Detach the device from the host system prior to attaching it to
      VM Guest.
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>virsh nodedev-detach pci_0000_03_07_0
  Device pci_0000_03_07_0 detached</pre></div><div id="idm139774764567776" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Multi-Function PCI Devices</h6><p>
       When using a multi-function PCI device that does not support FLR
       (function level reset) or PM (power management) reset, you need to
       detach all its functions from the VM Host Server. The whole device must be
       reset for security reasons. <code class="systemitem">libvirt</code> will
       refuse to assign the device if one of its functions is still in use
       by the VM Host Server or another VM Guest.
      </p></div></li><li class="step "><p>
      Convert the domain, bus, slot, and function value from decimal to
      hexadecimal, and prefix with <code class="literal">0x</code> to tell the
      system that the value is hexadecimal. In our example, domain = 0,
      bus = 3, slot = 7, and function = 0. Their hexadecimal values are:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>printf %x 0
0
<code class="prompt user">tux &gt; </code>printf %x 3
3
<code class="prompt user">tux &gt; </code>printf %x 7
7</pre></div><p>
      This results in domain = 0x0000, bus = 0x03, slot = 0x07 and function
      = 0x00.
     </p></li><li class="step "><p>
      Run <code class="command">virsh edit</code> on your domain, and add the
      following device entry in the <code class="literal">&lt;devices&gt;</code>
      section using the values from the previous step:
     </p><div class="verbatim-wrap"><pre class="screen">&lt;hostdev mode='subsystem' type='pci' managed='yes'&gt;
  &lt;source&gt;
    &lt;address domain='0x0000' bus='0x03' slot='0x07' function='0x0'/&gt;
  &lt;/source&gt;
&lt;/hostdev&gt;</pre></div><div id="tip.libvirt.config.pci.virsh.managed" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: <code class="literal">managed</code> Compared to <code class="literal">unmanaged</code></h6><p>
       <code class="systemitem">libvirt</code> recognizes two modes for handling
       PCI devices: they can be either <code class="literal">managed</code> or
       <code class="literal">unmanaged</code>. In the managed case,
       <code class="systemitem">libvirt</code> will do handle all details of
       unbinding the device from the existing driver if needed, resetting
       the device, binding it to <code class="systemitem">vfio-pci</code> before
       starting the domain, etc. When the domain is terminated or the device
       is removed from the domain, <code class="systemitem">libvirt</code> will
       unbind from <code class="systemitem">vfio-pci</code> and rebind to the
       original driver in the case of a managed device. If the device is
       unmanaged, the user must ensure all of these management
       aspects of the device are done before assigning it to a domain, and
       after the device is no longer used by the domain.
      </p><p>
       In the example above, the <code class="literal">managed='yes'</code> option
       means that the device is managed. To switch the device mode to
       unmanaged, set <code class="literal">managed='no'</code> in the listing above.
       If you do so, you need to take care of the related driver with the
       <code class="command">virsh nodedev-detach</code> and <code class="command">virsh
       nodedev-reattach</code> commands. That means you need to run
       <code class="command">virsh nodedev-detach pci_0000_03_07_0</code> prior to
       starting the VM Guest to detach the device from the host. In case
       the VM Guest is not running, you can make the device available for
       the host by running <code class="command">virsh nodedev-reattach
       pci_0000_03_07_0</code>.
      </p></div></li><li class="step "><p>
      Shut down the VM Guest and restart it to make the assigned PCI device
      available.
     </p><div id="idm139774764548720" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: SELinux</h6><p>
       If you are running SELinux on your VM Host Server, you need to disable it
       prior to starting the VM Guest with
      </p><div class="verbatim-wrap"><pre class="screen">setsebool -P virt_use_sysfs 1</pre></div></div></li></ol></div></div></div></div><div class="sect1 " id="sec.libvirt.config.usb"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.usb"><span class="number">13.11 </span><span class="name">Assigning a Host USB Device to a VM Guest</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.usb">#</a></h2></div></div></div><p>
   Analogous to assigning host PCI devices (see <a class="xref" href="cha.libvirt.config.html#sec.libvirt.config.pci" title="13.10. Assigning a Host PCI Device to a VM Guest">Section 13.10, “Assigning a Host PCI Device to a VM Guest”</a>), you can directly assign host USB devices to guests.
   When the USB device is assigned to one VM Guest, it cannot be used on
   the host or by another VM Guest unless it is re-assigned.
  </p><div class="sect2 " id="sec.libvirt.config.usb.vmm"><div class="titlepage"><div><div><h3 class="title" id="sec.libvirt.config.usb.vmm"><span class="number">13.11.1 </span><span class="name">Adding a USB Device with Virtual Machine Manager</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.usb.vmm">#</a></h3></div></div></div><p>
    To assign a host USB device to VM Guest using Virtual Machine Manager, follow these steps:
    </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      Double-click a VM Guest entry in the Virtual Machine Manager to open its console and
      switch to the <span class="guimenu">Details</span> view with <span class="guimenu">View</span> › <span class="guimenu">Details</span>.
     </p></li><li class="step "><p>
      Click <span class="guimenu">Add Hardware</span> and choose the <span class="guimenu">USB Host
      Device</span> category in the left panel. A list of available USB
      devices appears in the right part of the window.
     </p><div class="figure" id="idm139774764537200"><div class="figure-contents"><div class="mediaobject"><a xmlns="" href="images/virt_add_usbdevice.png"><img src="images/virt_add_usbdevice.png" width="" alt="Adding a USB Device" /></a></div></div><div class="figure-title-wrap"><h6 class="figure-title"><span class="number">Figure 13.13: </span><span class="name">Adding a USB Device </span><a title="Permalink" class="permalink" href="cha.libvirt.config.html#idm139774764537200">#</a></h6></div></div></li><li class="step "><p>
      From the list of available USB devices, choose the one you want to
      pass to the guest. Confirm with <span class="guimenu">Finish</span>.
      The new USB device appears in the left pane of the
      <span class="guimenu">Details</span> view.
     </p><div id="idm139774764530272" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: USB Device Removal</h6><p>
       To remove the host USB device assignment, click it in the left pane of
       the <span class="guimenu">Details</span> view and confirm with
       <span class="guimenu">Remove</span>.
      </p></div></li></ol></div></div></div><div class="sect2 " id="sec.libvirt.config.usb.virsh"><div class="titlepage"><div><div><h3 class="title" id="sec.libvirt.config.usb.virsh"><span class="number">13.11.2 </span><span class="name">Adding a USB Device with <code class="command">virsh</code></span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.usb.virsh">#</a></h3></div></div></div><p>
    To assign a USB device to VM Guest using <code class="command">virsh</code>,
    follow these steps:
   </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      Identify the host USB device to assign to the guest:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> <code class="command">lsusb</code>
[...]
Bus 001 Device 003: ID 0557:2221 ATEN International Co., Ltd Winbond Hermon
[...]</pre></div><p>
      Note down the vendor and product IDs. In our example, the vendor ID is
      <code class="literal">0557</code> and the product ID is <code class="literal">2221</code>.
     </p></li><li class="step "><p>
      Run <code class="command">virsh edit</code> on your domain, and add the
      following device entry in the <code class="literal">&lt;devices&gt;</code>
      section using the values from the previous step:
     </p><div class="verbatim-wrap"><pre class="screen">&lt;hostdev mode='subsystem' type='usb'&gt;
  &lt;source startupPolicy='optional'&gt;
   &lt;vendor id='0557'/&gt;
   &lt;product id='2221'/&gt;
  &lt;/source&gt;
&lt;/hostdev&gt;</pre></div><div id="idm139774764518560" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Vendor/Product or Device's Address</h6><p>
       Instead of defining the host device with &lt;vendor/&gt; and &lt;product/&gt; IDs, you
     can use the &lt;address/&gt; element as described for host PCI devices in <a class="xref" href="cha.libvirt.config.html#sec.libvirt.config.pci.virsh" title="13.10.2. Adding a PCI Device with virsh">Section 13.10.2, “Adding a PCI Device with <code class="command">virsh</code>”</a>.
      </p></div></li><li class="step "><p>
      Shut down the VM Guest and restart it to make the assigned USB device
      available.
     </p><div id="idm139774764515504" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: SELinux</h6><p>
       If you are running SELinux on your VM Host Server, you need to disable it
       prior to starting the VM Guest with
      </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>setsebool -P virt_use_sysfs 1</pre></div></div></li></ol></div></div></div></div><div class="sect1 " id="sec.libvirt.config.io"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.io"><span class="number">13.12 </span><span class="name">Adding SR-IOV Devices</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.io">#</a></h2></div></div></div><p>
   Single Root I/O Virtualization (<a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a>) capable
   <a class="xref" href="gloss.vt.glossary.html#gloss.vt.acronym.pcie" title="PCIe">PCIe</a> devices can replicate their
   resources, so they appear to be multiple devices. Each of these
   "pseudo-devices" can be assigned to a VM Guest.
  </p><p>
   <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> is an industry specification that was
   created by the Peripheral Component Interconnect Special Interest Group
   (PCI-SIG) consortium. It introduces physical functions (PF) and virtual
   functions (VF). PFs are full <a class="xref" href="gloss.vt.glossary.html#gloss.vt.acronym.pcie" title="PCIe">PCIe</a>
   functions used to manage and configure the device. PFs also can move
   data. VFs lack the configuration and management part—they only can
   move data and a reduced set of configuration functions. Since VFs do not
   have all <a class="xref" href="gloss.vt.glossary.html#gloss.vt.acronym.pcie" title="PCIe">PCIe</a> functions, the host
   operating system or the <a class="xref" href="gloss.vt.glossary.html#gloss.vt.hypervisor" title="Hypervisor">Hypervisor</a> must
   support <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> to be able to access and
   initialize VFs. The theoretical maximum for VFs is 256 per device
   (consequently the maximum for a dual-port Ethernet card would be 512). In
   practice this maximum is much lower, since each VF consumes resources.
  </p><div class="sect2 " id="sec.libvirt.config.io.requirements"><div class="titlepage"><div><div><h3 class="title" id="sec.libvirt.config.io.requirements"><span class="number">13.12.1 </span><span class="name">Requirements</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.io.requirements">#</a></h3></div></div></div><p>
    The following requirements must be met to be able to use
    <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a>:
   </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
      An <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a>-capable network card (as of
      <span class="productname"><span class="phrase">openSUSE Leap</span></span> <span class="productnumber"><span class="phrase">42.3</span></span>, only network cards support
      <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a>)
     </p></li><li class="listitem "><p>
      An AMD64/Intel 64 host supporting hardware virtualization (AMD-V or Intel
      VT-x)
     </p></li><li class="listitem "><p>
      A chipset that supports device assignment (AMD-Vi or Intel
      <a class="xref" href="gloss.vt.glossary.html#gloss.vt.acronym.vtd" title="VT-d">VT-d</a>)
     </p></li><li class="listitem "><p>
      libvirt-0.9.10 or better
     </p></li><li class="listitem "><p>
      <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> drivers must be loaded and configured on
      the host system
     </p></li><li class="listitem "><p>
      A host configuration that meets the requirements listed at
      <a class="xref" href="chap.virtualization.introduction.html#ann.vt.io.require" title="Important: Requirements for VFIO and SR-IOV">Important: Requirements for VFIO and SR-IOV</a>
     </p></li><li class="listitem "><p>
      A list of the PCI addresses of the VF(s) that will be assigned to
      VM Guests
     </p></li></ul></div><div id="idm139774764490880" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Checking if a Device is SR-IOV-Capable</h6><p>
     The information whether a device is SR-IOV-capable can be obtained from
     its PCI descriptor by running <code class="command">lspci</code>. A device that
     supports <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> reports a capability similar to
     the following:
    </p><div class="verbatim-wrap"><pre class="screen">Capabilities: [160 v1] Single Root I/O Virtualization (<a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a>)</pre></div></div><div id="idm139774764487312" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.png" /><h6>Note: Adding an SR-IOV Device at VM Guest Creation</h6><p>
     Before adding an SR-IOV device to a VM Guest when initially
     setting it up, the VM Host Server already needs to be configured as described
     in <a class="xref" href="cha.libvirt.config.html#sec.libvirt.config.io.config" title="13.12.2. Loading and Configuring the SR-IOV Host Drivers">Section 13.12.2, “Loading and Configuring the SR-IOV Host Drivers”</a>.
    </p></div></div><div class="sect2 " id="sec.libvirt.config.io.config"><div class="titlepage"><div><div><h3 class="title" id="sec.libvirt.config.io.config"><span class="number">13.12.2 </span><span class="name">Loading and Configuring the SR-IOV Host Drivers</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.io.config">#</a></h3></div></div></div><p>
    To be able to access and initialize VFs, an SR-IOV-capable driver needs
    to be loaded on the host system.

   </p><div class="procedure "><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
      Before loading the driver, make sure the card is properly detected by
      running <code class="command">lspci</code>. The following example shows the
      <code class="command">lspci</code> output for the dual-port Intel 82576NS
      network card:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> /sbin/lspci | grep 82576
01:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)</pre></div><p>
      In case the card is not detected, it is likely that the hardware
      virtualization support in the BIOS/EFI has not been enabled.
     </p></li><li class="step "><p>
      Check whether the <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> driver is already
      loaded by running <code class="command">lsmod</code>. In the following example a
      check for the igb driver (for the Intel 82576NS network card) returns
      a result. That means the driver is already loaded. If the command
      returns nothing, the driver is not loaded.
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> /sbin/lsmod | egrep "^igb "
igb                   185649  0</pre></div></li><li class="step "><p>
      Skip this step if the driver is already loaded.
     </p><p>
      If the <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> driver is not yet loaded, the
      non-<a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> driver needs to be removed first,
      before loading the new driver. Use <code class="command">rmmod</code> to unload
      a driver. The following example unloads the
      non-<a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> driver for the Intel 82576NS network
      card:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> /sbin/rmmod igbvf</pre></div><p>
      Load the <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> driver subsequently using
      the <code class="command">modprobe</code> command—the VF parameter
      (<code class="literal">max_vfs</code>) is mandatory:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> /sbin/modprobe igb max_vfs=8</pre></div><p>
      Or load the driver via SYSFS:
     </p><p>
      Find the PCI ID of the physical NIC by listing Ethernet devices:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> lspci | grep Eth
06:00.0 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)
06:00.1 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)</pre></div><p>
      To enable VFs, echo the number of desired VFs to load to the
      <code class="literal">sriov_numvfs</code> parameter:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> echo 1 &gt; /sys/bus/pci/devices/0000:06:00.1/sriov_numvfs</pre></div><p>Verify that the VF NIC was loaded:</p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> lspci | grep Eth
06:00.0 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)
06:00.1 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)
06:08.0 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)</pre></div><p>Obtain the maximum number of VFs available:</p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> lspci -vvv -s 06:00.1 | grep 'Initial VFs'
                       Initial VFs: 32, Total VFs: 32, Number of VFs: 0,
Function Dependency Link: 01</pre></div></li><li class="step "><p>
      Create a <code class="filename">before.service</code> file which loads VF via
      SYSFS on boot:
     </p><div class="verbatim-wrap"><pre class="screen">[Unit]
Before=
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=/bin/bash -c "echo 1 &gt; /sys/bus/pci/devices/0000:06:00.1/sriov_numvfs"
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</pre></div><p>
And copy it to <code class="filename">/etc/systemd/system</code>.
</p><p>
 Additionally, it is required to create another service file
 (<code class="filename">after-local.service</code>) pointing to
 <code class="filename">/etc/init.d/after.local</code> script that detaches the
 NIC prior to starting the VM, otherwise the VM would fail to start:
</p><div class="verbatim-wrap"><pre class="screen">[Unit]
Description=/etc/init.d/after.local Compatibility
After=libvirtd.service
Requires=libvirtd.service
[Service]
Type=oneshot
ExecStart=/etc/init.d/after.local
RemainAfterExit=true

[Install]
WantedBy=multi-user.target</pre></div><p>
And copy it to <code class="filename">/etc/systemd/system</code>.
</p><div class="verbatim-wrap"><pre class="screen">#! /bin/sh
#
# Copyright (c) 2010 SuSE LINUX Products GmbH, Germany.  All rights reserved.
# ...
virsh nodedev-detach pci_0000_06_08_0</pre></div><p>
Then save it as <code class="filename">/etc/init.d/after.local</code>.
</p></li><li class="step "><p>
      Reboot the machine and check if the SR-IOV driver is loaded by
      re-running the <code class="command">lspci</code> command from the first step of
      this procedure. If the SR-IOV driver was loaded successfully you
      should see additional lines for the VFs:
     </p><div class="verbatim-wrap"><pre class="screen">01:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:10.0 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
01:10.1 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
01:10.2 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
[...]
04:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:10.0 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
04:10.1 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
04:10.2 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
[...]</pre></div></li></ol></div></div></div><div class="sect2 " id="sec.libvirt.config.io.attach"><div class="titlepage"><div><div><h3 class="title" id="sec.libvirt.config.io.attach"><span class="number">13.12.3 </span><span class="name">Adding a VF Network Device to an Existing VM Guest</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.io.attach">#</a></h3></div></div></div><p>
    When the <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> hardware is properly set up on
    the VM Host Server, you can add VFs to VM Guests. To do so, you need to
    collect some data first.
   </p><div class="procedure "><div class="procedure-contents"><p>
     Note: The following procedure is using example data. Make sure to
     replace it by appropriate data from your setup.
    </p><ol class="procedure" type="1"><li class="step "><p>
      Use the <code class="command">virsh nodedev-list</code> command to get the PCI
      address of the VF you want to assign and its corresponding PF.
      Numerical values from the <code class="command">lspci</code> output shown in
      <a class="xref" href="cha.libvirt.config.html#sec.libvirt.config.io.config" title="13.12.2. Loading and Configuring the SR-IOV Host Drivers">Section 13.12.2, “Loading and Configuring the SR-IOV Host Drivers”</a> (for example
      <code class="literal">01:00.0</code> or <code class="literal">04:00.1</code>) are
      transformed by adding the prefix "pci_0000_" and by replacing colons
      and dots with underscores. So a PCI ID listed as "04:00.0" by
      <code class="command">lspci</code> is listed as "pci_0000_04_00_0" by virsh. The
      following example lists the PCI IDs for the second port of the Intel
      82576NS network card:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> virsh nodedev-list | grep 0000_04_
pci_0000_04_00_0
pci_0000_04_00_1
pci_0000_04_10_0
pci_0000_04_10_1
pci_0000_04_10_2
pci_0000_04_10_3
pci_0000_04_10_4
pci_0000_04_10_5
pci_0000_04_10_6
pci_0000_04_10_7
pci_0000_04_11_0
pci_0000_04_11_1
pci_0000_04_11_2
pci_0000_04_11_3
pci_0000_04_11_4
pci_0000_04_11_5</pre></div><p>
      The first two entries represent the PFs, whereas the other entries
      represent the VFs.
     </p></li><li class="step "><p>
      Get more data that will be needed by running the command
      <code class="command">virsh nodedev-dumpxml</code> on the PCI ID of the VF you
      want to add:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">sudo</code> virsh nodedev-dumpxml pci_0000_04_10_0
&lt;device&gt;
  &lt;name&gt;pci_0000_04_10_0&lt;/name&gt;
  &lt;parent&gt;pci_0000_00_02_0&lt;/parent&gt;
  &lt;capability type='pci'&gt;
    &lt;domain&gt;0&lt;/domain&gt;
    &lt;bus&gt;4&lt;/bus&gt;
    &lt;slot&gt;16&lt;/slot&gt;
    &lt;function&gt;0&lt;/function&gt;
    &lt;product id='0x10ca'&gt;82576 Virtual Function&lt;/product&gt;
    &lt;vendor id='0x8086'&gt;Intel Corporation&lt;/vendor&gt;
    &lt;capability type='phys_function'&gt;
      &lt;address domain='0x0000' bus='0x04' slot='0x00' function='0x0'/&gt;
    &lt;/capability&gt;
  &lt;/capability&gt;
&lt;/device&gt;</pre></div><p>
      The following data is needed for the next step:
     </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
        <code class="literal">&lt;domain&gt;0&lt;/domain&gt;</code>
       </p></li><li class="listitem "><p>
        <code class="literal">&lt;bus&gt;4&lt;/bus&gt;</code>
       </p></li><li class="listitem "><p>
        <code class="literal">&lt;slot&gt;16&lt;/slot&gt;</code>
       </p></li><li class="listitem "><p>
        <code class="literal">&lt;function&gt;0&lt;/function&gt;</code>
       </p></li></ul></div></li><li class="step "><p>
      Create a temporary XML file (for example
      <code class="filename">/tmp/vf-interface.xml</code> containing the data
      necessary to add a VF network device to an existing VM Guest. The
      minimal content of the file needs to look like the following:
     </p><div class="verbatim-wrap"><pre class="screen">&lt;interface type='hostdev'&gt;<span id="sriov.iface"></span><span class="callout">1</span>
 &lt;source&gt;
  &lt;address type='pci' domain='0' bus='11' slot='16' function='0'2/&gt;<span id="sriov.data"></span><span class="callout">2</span>
 &lt;/source&gt;
&lt;/interface&gt;</pre></div><div class="calloutlist "><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#sriov.iface"><span class="callout">1</span></a> </p></td><td valign="top" align="left"><p>
        VFs do not get a fixed MAC address; it changes every time the host
        reboots. When adding network devices the <span class="quote">“<span class="quote">traditional</span>”</span>
        way with &lt;hostdev&gt;, it would require to reconfigure the
        VM Guest's network device after each reboot of the host, because of
        the MAC address change. To avoid this kind of problem, libvirt
        introduced the <span class="quote">“<span class="quote">interface type='hostdev'</span>”</span> directive,
        which sets up network-specific data <span class="emphasis"><em>before</em></span>
        assigning the device.
       </p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#sriov.data"><span class="callout">2</span></a> </p></td><td valign="top" align="left"><p>
        Specify the data you acquired in the previous step here.
       </p></td></tr></table></div></li><li class="step "><p>
      In case a device is already attached to the host, it cannot be
      attached to a guest. To make it available for guests, detach it from
      the host first:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>virsh nodedev-detach pci_0000_04_10_0</pre></div></li><li class="step "><p>
      Last, add the VF interface to an existing VM Guest:
     </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>virsh attach-device <em class="replaceable ">GUEST</em> /tmp/vf-interface.xml --<em class="replaceable ">OPTION</em></pre></div><p>
      <em class="replaceable ">GUEST</em> needs to be replaced by the domain
      name, id or uuid of the VM Guest and
      --<em class="replaceable ">OPTION</em> can be one of the following:
     </p><div class="variablelist "><dl class="variablelist"><dt id="idm139774764417040"><span class="term "><code class="option">--persistent</code>
       </span></dt><dd><p>
         This option will always add the device to the domain's persistent
         XML. In addition, if the domain is running, it will be hotplugged.
        </p></dd><dt id="idm139774764414816"><span class="term "><code class="option">--config</code>
       </span></dt><dd><p>
         This option will only affect the persistent XML, even if the domain
         is running. The device will only show up in the guest on next boot.
        </p></dd><dt id="idm139774764412592"><span class="term "><code class="option">--live</code>
       </span></dt><dd><p>
         This option will only affect a running domain. If the domain is
         inactive, the operation will fail. The device is not persisted in
         the XML and will not be available in the guest on next boot.
        </p></dd><dt id="idm139774764410304"><span class="term "><code class="option">--current</code></span></dt><dd><p>
         This option affects the current state of the domain. If the domain
         is inactive, the device is added to the persistent XML and will be
         available on next boot. If the domain is active, the device is
         hotplugged but not added to the persistent XML.
        </p></dd></dl></div><p>
      To detach a VF interface, use the <code class="command">virsh
      detach-device</code> command, which also takes the options listed
      above.
     </p></li></ol></div></div></div><div class="sect2 " id="libvirt.config.io.pool"><div class="titlepage"><div><div><h3 class="title" id="libvirt.config.io.pool"><span class="number">13.12.4 </span><span class="name">Dynamic Allocation of VFs from a Pool</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#libvirt.config.io.pool">#</a></h3></div></div></div><p>
    If you define the PCI address of a VF into a guest's configuration
    statically as described in
    <a class="xref" href="cha.libvirt.config.html#sec.libvirt.config.io.attach" title="13.12.3. Adding a VF Network Device to an Existing VM Guest">Section 13.12.3, “Adding a VF Network Device to an Existing VM Guest”</a>, it is hard to migrate
    such guest to another host. The host must have identical hardware in the
    same location on the PCI bus, or the guest configuration must be
    modified prior to each start.
   </p><p>
    Another approach is to create a <code class="systemitem">libvirt</code> network with a device pool
    that contains all the VFs of an <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> device.
    The guest then references this network, and each time it is started, a
    single VF is dynamically allocated to it. When the guest is stopped, the
    VF is returned to the pool, available for another guest.
   </p><div class="sect3 " id="libvirt.config.io.pool.host"><div class="titlepage"><div><div><h4 class="title" id="libvirt.config.io.pool.host"><span class="number">13.12.4.1 </span><span class="name">Defining Network with Pool of VFs on VM Host Server</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#libvirt.config.io.pool.host">#</a></h4></div></div></div><p>
     The following example of network definition creates a pool of all VFs
     for the <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> device with its physical function
     (PF) at the network interface eth0 on the host:
    </p><div class="verbatim-wrap"><pre class="screen">&lt;network&gt;
  &lt;name&gt;passthrough&lt;/name&gt;
    &lt;forward mode='hostdev' managed='yes'&gt;
      &lt;pf dev='eth0'/&gt;
    &lt;/forward&gt;
  &lt;/network&gt;</pre></div><p>
     To use this network on the host, save the above code to a file, for
     example <code class="filename">/tmp/passthrough.xml</code>, and execute the
     following commands. Remember to replace eth0 with the real network
     interface name of your <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> device's PF:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>virsh net-define /tmp/passthrough.xml
<code class="prompt user">tux &gt; </code>virsh net-autostart passthrough
<code class="prompt user">tux &gt; </code>virsh net-start passthrough</pre></div></div><div class="sect3 " id="libvirt.config.io.pool.guest"><div class="titlepage"><div><div><h4 class="title" id="libvirt.config.io.pool.guest"><span class="number">13.12.4.2 </span><span class="name">Configuring VM Guest to Use VF from the Pool</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#libvirt.config.io.pool.guest">#</a></h4></div></div></div><p>
     The following example of guest device interface definition uses a VF of
     the <a class="xref" href="chap.virtualization.introduction.html#vt.io.sriov">SR-IOV</a> device from the pool created in
     <a class="xref" href="cha.libvirt.config.html#libvirt.config.io.pool.host" title="13.12.4.1. Defining Network with Pool of VFs on VM Host Server">Section 13.12.4.1, “Defining Network with Pool of VFs on VM Host Server”</a>. <code class="systemitem">libvirt</code> automatically
     derives the list of all VFs associated with that PF the first time the
     guest is started.
    </p><div class="verbatim-wrap"><pre class="screen">&lt;interface type='network'&gt;
  &lt;source network='passthrough'&gt;
&lt;/interface&gt;</pre></div><p>
     To verify the list of associated VFs, run <code class="command">virsh net-dumpxml
     passthrough</code> on the host after the first guest that uses the
     network with the pool of VFs starts.
    </p><div class="verbatim-wrap"><pre class="screen">&lt;network connections='1'&gt;
  &lt;name&gt;passthrough&lt;/name&gt;
  &lt;uuid&gt;a6a26429-d483-d4ed-3465-4436ac786437&lt;/uuid&gt;
  &lt;forward mode='hostdev' managed='yes'&gt;
    &lt;pf dev='eth0'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x1'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x3'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x5'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x7'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x1'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x3'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x5'/&gt;
  &lt;/forward&gt;
  &lt;/network&gt;</pre></div></div></div></div><div class="sect1 " id="sec.libvirt.config.direct"><div class="titlepage"><div><div><h2 class="title" id="sec.libvirt.config.direct"><span class="number">13.13 </span><span class="name">Using Macvtap to Share VM Host Server Network Interfaces</span> <a title="Permalink" class="permalink" href="cha.libvirt.config.html#sec.libvirt.config.direct">#</a></h2></div></div></div><p>
   Macvtap provides direct attachment of a VM Guest virtual interface
   to a host network interface. The macvtap-based interface extends the
   VM Host Server network interface and has its own MAC address on the same
   Ethernet segment. Typically, this is used to make both the VM Guest
   and the VM Host Server show up directly on the switch that the VM Host Server is
   connected to.
  </p><div id="idm139774764386656" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.png" /><h6>Note: Macvtap Cannot Be Used With a Linux Bridge</h6><p>
    Macvtap cannot be used with network interfaces already connected
    to a linux bridge. Before attempting to create the macvtap interface,
    remove the interface from the bridge.
   </p></div><div id="idm139774764385104" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.png" /><h6>Note: VM Guest to VM Host Server Communication with Macvtap</h6><p>
    When using macvtap, a VM Guest can communicate with other
    VM Guests, and with other external hosts on the network. But it
    cannot communicate with the VM Host Server on which the VM Guest runs.
    This is the defined behavior of macvtap, because of the way the
    VM Host Server's physical Ethernet is attached to the macvtap bridge.
    Traffic from the VM Guest into that bridge that is forwarded to
    the physical interface cannot be bounced back up to the VM Host Server's
    IP stack. Similarly, traffic from the VM Host Server's IP stack that is
    sent to the physical interface cannot be bounced back up to the
    macvtap bridge for forwarding to the VM Guest.
   </p></div><p>
   Virtual network interfaces based on macvtap are supported by libvirt
   by specifying an interface type of <code class="literal">direct</code>. For example:
  </p><div class="verbatim-wrap"><pre class="screen">&lt;interface type='direct'&gt;
  &lt;mac address='aa:bb:cc:dd:ee:ff'/&gt;
  &lt;source dev='eth0' mode='bridge'/&gt;
  &lt;model type='virtio'/&gt;
  &lt;/interface&gt;</pre></div><p>
   The operation mode of the macvtap device can be controlled with
   the <code class="literal">mode</code> attribute. The following lists shows its possible
   values and a description for each:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     <code class="literal">vepa</code>: All VM Guest packets are sent to an external bridge. Packets
     whose destination is a VM Guest on the same VM Host Server as where the
     packet originates from are sent back to the VM Host Server by the VEPA
     capable bridge (today's bridges are typically not VEPA capable).
    </p></li><li class="listitem "><p>
     <code class="literal">bridge</code>: Packets whose destination is on the same VM Host Server where
     they originate from are directly delivered to the target macvtap
     device. Both origin and destination devices need to be in <code class="literal">bridge</code>
     mode for direct delivery. If either one of them is in <code class="literal">vepa</code> mode, a
     VEPA capable bridge is required.
    </p></li><li class="listitem "><p>
     <code class="literal">private</code>: All packets are sent to the external bridge and will only
     be delivered to a target VM Guest on the same VM Host Server if they are
     sent through an external router or gateway and that device sends
     them back to the VM Host Server. This procedure is followed if either the
     source or destination device is in private mode.
    </p></li><li class="listitem "><p>
     <code class="literal">passthrough</code>: A special mode that gives more power to the network
     interface. All packets will be forwarded to the interface, allowing
     virtio VM Guests to change the MAC address or set promiscuous mode
     to bridge the interface or create VLAN interfaces on top
     of it. Note that a network interface is not shareable in <code class="literal">passthrough</code>
     mode. Assigning an interface to a VM Guest will disconnect it from
     the VM Host Server. For this reason SR-IOV virtual functions are often
     assigned to the VM Guest in <code class="literal">passthrough</code> mode.
    </p></li></ul></div></div></div></div><div class="page-bottom"><div id="_bottom-navigation"><a class="nav-link" href="part.virt.common.html"><span class="next-icon">→</span><span class="nav-label"><span class="number">Part III </span>Hypervisor-Independent Features</span></a><a class="nav-link" href="cha.libvirt.networks.html"><span class="prev-icon">←</span><span class="nav-label"><span class="number">Chapter 12 </span>Managing Networks</span></a></div><div id="_share-print"><div class="online-contents share"><strong>Share this page: </strong><span class="share-buttons"><span id="_share-fb" class="bottom-button">Facebook</span><span class="spacer"> • </span><span id="_share-gp" class="bottom-button">Google+</span><span class="spacer"> • </span><span id="_share-tw" class="bottom-button">Twitter</span></span></div><div class="print"><span id="_print-button" class="bottom-button">Print this page</span></div><div class="clearme"></div></div></div></div><div id="_inward"></div></div><div id="_footer-wrap"><div id="_footer"><p>©
        2018 
        SUSE</p></div></div></body></html>