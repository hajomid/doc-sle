<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Introduction to the Booting Process | Administration Guide | SUSE Linux Enterprise Server 15</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /><link rel="stylesheet" type="text/css" href="static/css/style.css" /><link rel="stylesheet" type="text/css" href="static/css/highlight.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="product-name" content="SUSE Linux Enterprise Server" /><meta name="product-number" content="15" /><meta name="book-title" content="Administration Guide" /><meta name="chapter-title" content="Chapter 10. Introduction to the Booting Process" /><meta name="description" content="Booting a Linux system involves different components and tasks. The hardware itself is initialized by the BIOS or the UEFI, which starts the kernel by means of a boot loader. After this point, the boot process is completely controlled by the operating system and handled by systemd. systemd provides a set of targets that boot setups for everyday usage, maintenance or emergencies." /><meta name="tracker-url" content="https://bugzilla.suse.com/enter_bug.cgi" /><meta name="tracker-type" content="bsc" /><meta name="tracker-bsc-assignee" content="fs@suse.com" /><meta name="tracker-bsc-component" content="Documentation" /><meta name="tracker-bsc-product" content="SUSE Linux Enterprise Server 15" /><link rel="home" href="index.html" title="SUSE Linux Enterprise Server Documentation" /><link rel="up" href="part.boot.html" title="Part II. Booting a Linux System" /><link rel="prev" href="part.boot.html" title="Part II. Booting a Linux System" /><link rel="next" href="cha.uefi.html" title="Chapter 11. UEFI (Unified Extensible Firmware Interface)" /><script type="text/javascript">

var protocol = window.location.protocol.toLowerCase();
if ( protocol != 'file:' ) {
  var agent = navigator.userAgent.toLowerCase();
  var wanted = ( protocol == 'https:') ? 'https' : 'http';
  var file = 'fonts.css';
  document.write('<link rel="stylesheet" type="text/css" href="' + wanted + '://static.opensuse.org/fonts/'+ file +'"></link>');
}
else {
   document.write('<link rel="stylesheet" type="text/css" href="static/css/fonts-onlylocal.css"></link>');
}

</script><noscript><link rel="stylesheet" type="text/css" href="http://static.opensuse.org/fonts/fonts.css" /></noscript><script src="static/js/jquery-1.10.2.min.js" type="text/javascript"></script><script src="static/js/script.js" type="text/javascript"></script><script src="static/js/highlight.min.js" type="text/javascript"></script><script>

$(document).ready(function() {
  $('.verbatim-wrap.highlight').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
hljs.configure({
  useBR: false
});

</script></head><body class="draft offline js-off"><div id="_outer-wrap"><div id="_white-bg"><div id="_header"><div id="_logo"><img src="static/images/logo.png" alt="Logo" /></div><div class="crumbs"><a class="book-link" href="index.html" title="SUSE Linux Enterprise Server Documentation"><span class="book-icon">SUSE Linux Enterprise Server Documentation</span></a><span> › </span><a class="crumb" href="book.sle.admin.html">Administration Guide</a><span> › </span><a class="crumb" href="part.boot.html">Booting a Linux System</a><span> › </span><a class="crumb" href="cha.boot.html">Introduction to the Booting Process</a></div><div class="clearme"></div></div></div><div id="_toolbar-wrap"><div id="_toolbar"><div id="_toc-area" class="inactive"><a id="_toc-area-button" class="tool" title="Contents" accesskey="c" href="index.html"><span class="tool-spacer"><span class="toc-icon">Contents</span><span class="clearme"></span></span><span class="tool-label">Contents</span></a><div class="active-contents bubble-corner"></div><div class="active-contents bubble"><div class="bubble-container"><h6>Administration Guide</h6><div id="_bubble-toc"><ol><li class="inactive"><a href="pre.sle.html"><span class="number"> </span><span class="name">About This Guide</span></a></li><li class="inactive"><a href="part.administration.html"><span class="number">I </span><span class="name">Common Tasks</span></a><ol><li class="inactive"><a href="cha.adm.shell.html"><span class="number">1 </span><span class="name">Bash and Bash Scripts</span></a></li><li class="inactive"><a href="cha.adm.sudo.html"><span class="number">2 </span><span class="name">sudo
</span></a></li><li class="inactive"><a href="cha.onlineupdate.you.html"><span class="number">3 </span><span class="name">YaST Online Update</span></a></li><li class="inactive"><a href="cha.yast.gui.html"><span class="number">4 </span><span class="name">YaST</span></a></li><li class="inactive"><a href="cha.yast.text.html"><span class="number">5 </span><span class="name">YaST in Text Mode</span></a></li><li class="inactive"><a href="cha.sw_cl.html"><span class="number">6 </span><span class="name">Managing Software with Command Line Tools</span></a></li><li class="inactive"><a href="cha.snapper.html"><span class="number">7 </span><span class="name">System Recovery and Snapshot Management with Snapper</span></a></li><li class="inactive"><a href="cha.vnc.html"><span class="number">8 </span><span class="name">Remote Access with VNC</span></a></li><li class="inactive"><a href="cha.net.rsync.html"><span class="number">9 </span><span class="name">File Copying with RSync</span></a></li></ol></li><li class="inactive"><a href="part.boot.html"><span class="number">II </span><span class="name">Booting a Linux System</span></a><ol><li class="inactive"><a href="cha.boot.html"><span class="number">10 </span><span class="name">Introduction to the Booting Process</span></a></li><li class="inactive"><a href="cha.uefi.html"><span class="number">11 </span><span class="name">UEFI (Unified Extensible Firmware Interface)</span></a></li><li class="inactive"><a href="cha.grub2.html"><span class="number">12 </span><span class="name">The Boot Loader GRUB 2</span></a></li><li class="inactive"><a href="cha.systemd.html"><span class="number">13 </span><span class="name">The <code class="systemitem">systemd</code> Daemon</span></a></li></ol></li><li class="inactive"><a href="part.system.html"><span class="number">III </span><span class="name">System</span></a><ol><li class="inactive"><a href="cha.64bit.html"><span class="number">14 </span><span class="name">32-Bit and 64-Bit Applications in a 64-Bit System Environment</span></a></li><li class="inactive"><a href="cha.journalctl.html"><span class="number">15 </span><span class="name"><code class="command">journalctl</code>: Query the <code class="systemitem">systemd</code> Journal</span></a></li><li class="inactive"><a href="cha.update-alternative.html"><span class="number">16 </span><span class="name"><code class="command">update-alternatives</code>: Managing Multiple Versions of Commands and Files</span></a></li><li class="inactive"><a href="cha.network.html"><span class="number">17 </span><span class="name">Basic Networking</span></a></li><li class="inactive"><a href="cha.print.html"><span class="number">18 </span><span class="name">Printer Operation</span></a></li><li class="inactive"><a href="cha.x11.html"><span class="number">19 </span><span class="name">The X Window System</span></a></li><li class="inactive"><a href="cha.fuse.html"><span class="number">20 </span><span class="name">Accessing File Systems with FUSE</span></a></li><li class="inactive"><a href="cha.mod.html"><span class="number">21 </span><span class="name">Managing Kernel Modules</span></a></li><li class="inactive"><a href="cha.udev.html"><span class="number">22 </span><span class="name">Dynamic Kernel Device Management with <code class="systemitem">udev</code></span></a></li><li class="inactive"><a href="cha.kgraft.html"><span class="number">23 </span><span class="name">Live Patching the Linux Kernel Using kGraft</span></a></li><li class="inactive"><a href="cha.suse.html"><span class="number">24 </span><span class="name">Special System Features</span></a></li><li class="inactive"><a href="cha.nm.html"><span class="number">25 </span><span class="name">Using NetworkManager</span></a></li><li class="inactive"><a href="cha.power-mgmt.html"><span class="number">26 </span><span class="name">Power Management</span></a></li></ol></li><li class="inactive"><a href="part.services.html"><span class="number">IV </span><span class="name">Services</span></a><ol><li class="inactive"><a href="cha.ntp.html"><span class="number">27 </span><span class="name">Time Synchronization with NTP</span></a></li><li class="inactive"><a href="cha.dns.html"><span class="number">28 </span><span class="name">The Domain Name System</span></a></li><li class="inactive"><a href="cha.dhcp.html"><span class="number">29 </span><span class="name">DHCP</span></a></li><li class="inactive"><a href="cha.nfs.html"><span class="number">30 </span><span class="name">Sharing File Systems with NFS</span></a></li><li class="inactive"><a href="cha.samba.html"><span class="number">31 </span><span class="name">Samba</span></a></li><li class="inactive"><a href="cha.autofs.html"><span class="number">32 </span><span class="name">On-Demand Mounting with Autofs</span></a></li><li class="inactive"><a href="cha.slp.html"><span class="number">33 </span><span class="name">SLP</span></a></li><li class="inactive"><a href="cha.apache2.html"><span class="number">34 </span><span class="name">The Apache HTTP Server</span></a></li><li class="inactive"><a href="cha.ftp.html"><span class="number">35 </span><span class="name">Setting Up an FTP Server with YaST</span></a></li><li class="inactive"><a href="cha.squid.html"><span class="number">36 </span><span class="name">The Proxy Server Squid</span></a></li><li class="inactive"><a href="cha.wbem.html"><span class="number">37 </span><span class="name">Web Based Enterprise Management Using SFCB</span></a></li></ol></li><li class="inactive"><a href="part.trouble.html"><span class="number">V </span><span class="name">Troubleshooting</span></a><ol><li class="inactive"><a href="cha.adminhelp.html"><span class="number">38 </span><span class="name">Help and Documentation</span></a></li><li class="inactive"><a href="cha.adm.support.html"><span class="number">39 </span><span class="name">Gathering System Information for Support</span></a></li><li class="inactive"><a href="cha.trouble.html"><span class="number">40 </span><span class="name">Common Problems and Their Solutions</span></a></li></ol></li><li class="inactive"><a href="app.nwscheme.html"><span class="number">A </span><span class="name">An Example Network</span></a></li><li class="inactive"><a href="bk01apb.html"><span class="number">B </span><span class="name">GNU Licenses</span></a></li></ol></div><div class="clearme"></div></div></div></div><div id="_nav-area" class="inactive"><div class="tool"><span class="nav-inner"><span class="tool-label">Navigation</span><a accesskey="p" class="tool-spacer" title="Part II. Booting a Linux System" href="part.boot.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Chapter 11. UEFI (Unified Extensible Firmware Interface)" href="cha.uefi.html"><span class="next-icon">→</span></a></span></div></div></div></div><div id="_fixed-header-wrap" class="inactive"><div id="_fixed-header"><div class="crumbs"><a class="book-link" href="index.html" title="SUSE Linux Enterprise Server Documentation"><span class="book-icon">SUSE Linux Enterprise Server Documentation</span></a><span> › </span><a class="crumb" href="book.sle.admin.html">Administration Guide</a><span> › </span><a class="crumb" href="part.boot.html">Booting a Linux System</a><span> › </span><a class="crumb" href="cha.boot.html">Introduction to the Booting Process</a></div><div class="buttons"><a class="top-button button" href="#">Top</a><div class="button"><a accesskey="p" class="tool-spacer" title="Part II. Booting a Linux System" href="part.boot.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Chapter 11. UEFI (Unified Extensible Firmware Interface)" href="cha.uefi.html"><span class="next-icon">→</span></a></div><div class="clearme"></div></div><div class="clearme"></div></div></div><div id="_content" class="draft "><div class="documentation"><div class="chapter " id="cha.boot"><div class="titlepage"><div><div class="version-info">Applies to  <span class="productname"><span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span></span> <span class="productnumber"><span class="productnumber"><span class="phrase">15</span></span></span></div><div><h2 class="title"><span class="number">10 </span><span class="name">Introduction to the Booting Process</span> </h2><div class="doc-status"><ul><li><span class="ds-label">Filename: </span>bootconcept.xml</li><li><span class="ds-label">ID: </span>cha.boot</li></ul></div></div><div><div class="abstract"><div class="abstract-title-wrap"><h6 class="abstract-title">Abstract<a title="Permalink" class="permalink" href="cha.boot.html#idm140310248445024">#</a></h6></div><p>
    Booting a Linux system involves different components and tasks. The
    hardware itself is initialized by the BIOS or the UEFI, which starts the
    kernel by means of a boot loader. After this point, the boot process is
    completely controlled by the operating system and handled by <code class="systemitem">systemd</code>.
    <code class="systemitem">systemd</code> provides a set of <span class="quote">“<span class="quote">targets</span>”</span> that boot setups for
    everyday usage, maintenance or emergencies.
   </p></div></div></div></div><div class="line"><div class="toc"><dl><dt><span class="sect1"><a href="cha.boot.html#sec.boot.proc"><span class="number">10.1 </span><span class="name">The Linux Boot Process</span></a></span></dt><dt><span class="sect1"><a href="cha.boot.html#sec.boot.initrd"><span class="number">10.2 </span><span class="name"><code class="systemitem">initramfs</code></span></a></span></dt><dt><span class="sect1"><a href="cha.boot.html#sec.boot.linuxrc"><span class="number">10.3 </span><span class="name">Init on <code class="systemitem">initramfs</code></span></a></span></dt></dl></div></div><div class="sect1 " id="sec.boot.proc"><div class="titlepage"><div><div><h2 class="title" id="sec.boot.proc"><span class="number">10.1 </span><span class="name">The Linux Boot Process</span> <a title="Permalink" class="permalink" href="cha.boot.html#sec.boot.proc">#</a></h2></div></div></div><p>
   The Linux boot process consists of several stages, each represented by a
   different component. The following list briefly summarizes the boot process
   and features all the major components involved:
  </p><div class="orderedlist "><ol class="orderedlist" type="1"><li class="listitem "><p><span class="formalpara-title">BIOS/UEFI. </span>
      After turning on the computer, the BIOS or the UEFI initializes the
      screen and keyboard, and tests the main memory. Up to this stage, the
      machine does not access any mass storage media. Subsequently, the
      information about the current date, time, and the most important
      peripherals are loaded from the CMOS values. When the first hard disk and
      its geometry are recognized, the system control passes from the BIOS to
      the boot loader. If the BIOS supports network booting, it is also
      possible to configure a boot server that provides the boot loader. On
      AMD64/Intel 64 systems, PXE boot is needed. Other architectures
      commonly use the BOOTP protocol to get the boot loader.
      For more information on UEFI, refer to <a class="xref" href="cha.uefi.html" title="Chapter 11. UEFI (Unified Extensible Firmware Interface)">Chapter 11, <em>UEFI (Unified Extensible Firmware Interface)</em></a>.
     </p></li><li class="listitem "><p><span class="formalpara-title">Boot Loader. </span>
      The first physical 512-byte data sector of the first hard disk is loaded
      into the main memory and the <span class="emphasis"><em>boot loader</em></span> that
      resides at the beginning of this sector takes over. The commands executed
      by the boot loader determine the remaining part of the boot process.
      Therefore, the first 512 bytes on the first hard disk are called the
      <span class="emphasis"><em>Master Boot Record</em></span> (MBR). The boot loader then
      passes control to the actual operating system, in this case, the Linux
      kernel. More information about GRUB 2, the Linux boot loader, can be
      found in <a class="xref" href="cha.grub2.html" title="Chapter 12. The Boot Loader GRUB 2">Chapter 12, <em>The Boot Loader GRUB 2</em></a>. For a network boot, the BIOS acts
      as the boot loader. It gets the boot image from the boot server and
      starts the system. This is completely independent of local hard disks.
     </p><p>
     If the root file system fails to mount from within the boot environment,
     it must be checked and repaired before the boot can continue. The file
     system checker will be automatically started for Ext3 and Ext4 file
     systems. The repair process is not automated for XFS and Btrfs file
     systems, and the user is be presented with information describing the
     options available to repair the file system. When the file system has been
     successfully repaired, exiting the boot environment will cause the system
     to retry mounting the root file system. If successful, the boot will
     continue normally.
    </p></li><li class="listitem "><p><span class="formalpara-title">Kernel and <code class="systemitem">initramfs</code>. </span>
      To pass system control, the boot loader loads both the kernel and an
      initial RAM-based file system (<code class="systemitem">initramfs</code>) into
      memory. The contents of the <code class="systemitem">initramfs</code> can be
      used by the kernel directly. <code class="systemitem">initramfs</code> contains
      a small executable called <code class="systemitem">init</code> that handles the
      mounting of the real root file system. If special hardware drivers are
      needed before the mass storage can be accessed, they must be in
      <code class="systemitem">initramfs</code>. For more information about
      <code class="systemitem">initramfs</code>, refer to
      <a class="xref" href="cha.boot.html#sec.boot.initrd" title="10.2. initramfs">Section 10.2, “<code class="systemitem">initramfs</code>”</a>. If the system does not have a
      local hard disk, the <code class="systemitem">initramfs</code> must provide the
      root file system for the kernel. This can be done using a network block
      device like iSCSI or SAN, but it is also possible to use NFS as the root
      device.
     </p><div id="idm140310248423792" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.png" /><h6>Note: The <code class="systemitem">init</code> Process Naming</h6><p>
      Two different programs are commonly named <span class="quote">“<span class="quote">init</span>”</span>:
     </p><div class="orderedlist "><ol class="orderedlist" type="a"><li class="listitem "><p>
        the <code class="systemitem">initramfs</code> process mounting the root file
        system
       </p></li><li class="listitem "><p>
        the operating system process setting up the system
       </p></li></ol></div><p>
      In this chapter we will therefore refer to them as
      <span class="quote">“<span class="quote"><code class="systemitem">init</code> on
      <code class="systemitem">initramfs</code></span>”</span> and <span class="quote">“<span class="quote"><code class="systemitem">systemd</code></span>”</span>,
      respectively.
     </p></div></li><li class="listitem "><p><span class="formalpara-title"><code class="systemitem">init</code> on <code class="systemitem">initramfs</code>. </span>
      This program performs all actions needed to mount the proper root file
      system. It provides kernel functionality for the needed file system and
      device drivers for mass storage controllers with
      <code class="systemitem">udev</code>. After the root file system
      has been found, it is checked for errors and mounted. If this is
      successful, the <code class="systemitem">initramfs</code> is cleaned and the
      <code class="systemitem">systemd</code> daemon on the root file system is executed. For more
      information about <code class="systemitem">init</code> on
      <code class="systemitem">initramfs</code>, refer to
      <a class="xref" href="cha.boot.html#sec.boot.linuxrc" title="10.3. Init on initramfs">Section 10.3, “Init on <code class="systemitem">initramfs</code>”</a>. Find more information about
      <code class="systemitem">udev</code> in
      <a class="xref" href="cha.udev.html" title="Chapter 22. Dynamic Kernel Device Management with udev">Chapter 22, <em>Dynamic Kernel Device Management with <code class="systemitem">udev</code></em></a>.
     </p></li><li class="listitem "><p><span class="formalpara-title"><code class="systemitem">systemd</code>. </span>
      By starting services and mounting file systems, <code class="systemitem">systemd</code> handles the
      actual booting of the system. <code class="systemitem">systemd</code> is described in
      <a class="xref" href="cha.systemd.html" title="Chapter 13. The systemd Daemon">Chapter 13, <em>The <code class="systemitem">systemd</code> Daemon</em></a>.
     </p></li></ol></div></div><div class="sect1 " id="sec.boot.initrd"><div class="titlepage"><div><div><h2 class="title" id="sec.boot.initrd"><span class="number">10.2 </span><span class="name"><code class="systemitem">initramfs</code></span> <a title="Permalink" class="permalink" href="cha.boot.html#sec.boot.initrd">#</a></h2></div></div></div><p>
   <code class="systemitem">initramfs</code> is a small cpio archive that the kernel
   can load into a RAM disk. It provides a minimal Linux environment that
   enables the execution of programs before the actual root file system is
   mounted. This minimal Linux environment is loaded into memory by BIOS or
   UEFI routines and does not have specific hardware requirements other than
   sufficient memory. The <code class="systemitem">initramfs</code> archive must
   always provide an executable named <code class="systemitem">init</code> that
   executes the <code class="systemitem">systemd</code> daemon on the root file system for the boot process
   to proceed.
  </p><p>
   Before the root file system can be mounted and the operating system can be
   started, the kernel needs the corresponding drivers to access the device on
   which the root file system is located. These drivers may include special
   drivers for certain kinds of hard disks or even network drivers to access a
   network file system. The needed modules for the root file system may be
   loaded by <code class="systemitem">init</code> on
   <code class="systemitem">initramfs</code>. After the modules are loaded,
   <code class="systemitem">udev</code> provides the
   <code class="systemitem">initramfs</code> with the needed devices. Later in the
   boot process, after changing the root file system, it is necessary to
   regenerate the devices. This is done by the <code class="systemitem">systemd</code> unit
   <code class="filename">udev.service</code> with the command
   <code class="command">udevtrigger</code>.
  </p><p>
   If you need to change hardware (for example, hard disks), and this hardware requires different drivers to be in the kernel at
   boot time, you must update the <code class="systemitem">initramfs</code> file. This
   is done by calling <code class="command">dracut</code> <code class="option">-f</code> (the option
   <code class="option">-f</code> overwrites the existing initramfs file). To add a driver
   for the new hardware, edit
   <code class="filename">/etc/dracut.conf.d/01-dist.conf</code> and add the following
   line. If the file does not exist, create it.
  </p><div class="verbatim-wrap"><pre class="screen">force_drivers+="<em class="replaceable ">DRIVER1</em>"</pre></div><p>
   Replace <em class="replaceable ">DRIVER1</em> with the module name of the
   driver. If you need to add more than one driver, list them space-separated
   (<code class="literal"><em class="replaceable ">DRIVER1</em>
   <em class="replaceable ">DRIVER2</em></code>).
  </p><div id="idm140310248389120" class="admonition important normal"><img class="symbol" alt="Important" title="Important" src="static/images/icon-important.png" /><h6>Important: Updating <code class="systemitem">initramfs</code> or <code class="systemitem">init</code></h6><p>
    The boot loader loads <code class="systemitem">initramfs</code> or
    <code class="systemitem">init</code> in the same way as the kernel. It is not
    necessary to re-install GRUB 2 after updating
    <code class="systemitem">initramfs</code> or <code class="systemitem">init</code>,
    because GRUB 2 searches the directory for the right file when booting.
   </p></div><div id="idm140310248385088" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.png" /><h6>Tip: Changing Kernel Variables</h6><p>
    If you change the values of kernel variables via the
    <code class="command">sysctl</code> interface by editing related files
    (<code class="filename">/etc/sysctl.conf</code> or
    <code class="filename">/etc/sysctl.d/*.conf</code>), the change will be lost on the
    next system reboot. Even if you load the values with <code class="command">sysctl
    --system</code> at runtime, the changes are not saved into the initramfs
    file. You need to update it by calling <code class="command">dracut</code>
    <code class="option">-f</code> (the option <code class="option">-f</code> overwrites the existing
    initramfs file).
   </p></div></div><div class="sect1 " id="sec.boot.linuxrc"><div class="titlepage"><div><div><h2 class="title" id="sec.boot.linuxrc"><span class="number">10.3 </span><span class="name">Init on <code class="systemitem">initramfs</code></span> <a title="Permalink" class="permalink" href="cha.boot.html#sec.boot.linuxrc">#</a></h2></div></div></div><p>
   The main purpose of <code class="systemitem">init</code> on
   <code class="systemitem">initramfs</code> is to prepare the mounting of and access
   to the real root file system. Depending on your system configuration,
   <code class="systemitem">init</code> on <code class="systemitem">initramfs</code> is
   responsible for the following tasks.
  </p><div class="variablelist "><dl class="variablelist"><dt id="idm140310248376032"><span class="term ">Loading Kernel Modules</span></dt><dd><p>
      Depending on your hardware configuration, special drivers may be needed
      to access the hardware components of your computer (the most important
      component being your hard disk). To access the final root file system,
      the kernel needs to load the proper file system drivers.
     </p></dd><dt id="idm140310248373952"><span class="term ">Providing Block Special Files</span></dt><dd><p>
      For each loaded module, the kernel generates device events.
      <code class="systemitem">udev</code> handles these events and
      generates the required special block files on a RAM file system in
      <code class="filename">/dev</code>. Without those special files, the file system
      and other devices would not be accessible.
     </p></dd><dt id="idm140310248370736"><span class="term ">Managing RAID and LVM Setups</span></dt><dd><p>
      If you configured your system to hold the root file system under RAID or
      LVM, <code class="systemitem">init</code> on <code class="systemitem">initramfs</code>
      sets up LVM or RAID to enable access to the root file system later.
     </p><p>
      To change your <code class="filename">/usr</code> or
      <code class="systemitem">swap</code> partitions directly without the help of
      YaST, further actions are needed. If you forget these steps, your
      system will start in emergency mode. To avoid starting in emergency mode,
      perform the following steps:
     </p><div class="procedure " id="pro.boot.linuxrc.lvm"><div class="procedure-title-wrap"><h6 class="procedure-title"><span class="number">Procedure 10.1: </span><span class="name">Updating Init RAM Disk When Switching to Logical Volumes </span><a title="Permalink" class="permalink" href="cha.boot.html#pro.boot.linuxrc.lvm">#</a></h6></div><div class="procedure-contents"><ol class="procedure" type="1"><li class="step "><p>
        Edit the corresponding entry in <code class="filename">/etc/fstab</code> and
        replace your previous partitions with the logical volume.
       </p></li><li class="step "><p>
        Execute the following commands:
       </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">mount</code> -a
<code class="prompt root">root # </code><code class="command">swapon</code> -a</pre></div></li><li class="step "><p>
        Regenerate your initial RAM disk (initramfs) with
        <code class="command">mkinitrd</code> or <code class="command">dracut</code>.
       </p></li><li class="step "><p>
        For z Systems, additionally run <code class="command">grub2-install</code>.
       </p></li></ol></div></div><p>
      Find more information about RAID and LVM in
      <span class="intraxref">Book “<em class="citetitle ">Deployment Guide</em>”, Chapter 15 “Advanced Disk Setup”</span>.
     </p></dd><dt id="ve.net"><span class="term ">Managing Network Configuration</span></dt><dd><p>
      If you configured your system to use a network-mounted root file system
      (mounted via NFS), <code class="systemitem">init</code> on
      <code class="systemitem">initramfs</code> must make sure that the proper network
      drivers are loaded and that they are set up to allow access to the root
      file system.
     </p><p>
      If the file system resides on a network block device like iSCSI or SAN,
      the connection to the storage server is also set up by
      <code class="systemitem">init</code> on <code class="systemitem">initramfs</code>.
      <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> supports booting from a secondary iSCSI target if the
      primary target is not available. <span class="phrase">For more details
      regarding configuration of the booting iSCSI target refer to
      <span class="intraxref">Book “<em class="citetitle ">Storage Administration Guide</em>”, Chapter 14 “Mass Storage over IP Networks: iSCSI”, Section 14.3.1 “Using YaST for the iSCSI Initiator Configuration”</span></span>.
     </p></dd></dl></div><p>
   When <code class="systemitem">init</code> on <code class="systemitem">initramfs</code> is
   called during the initial boot as part of the installation process, its
   tasks differ from those mentioned above:
  </p><div class="variablelist "><dl class="variablelist"><dt id="idm140310248346832"><span class="term ">Finding the Installation Medium</span></dt><dd><p>
      When starting the installation process, your machine loads an
      installation kernel and a special <code class="systemitem">init</code>
      containing the YaST installer. The YaST installer is running in a RAM
      file system and needs to have information about the location of the
      installation medium to access it for installing the operating system.
     </p></dd><dt id="idm140310248344256"><span class="term ">
      Initiating Hardware Recognition and Loading Appropriate Kernel Modules
     </span></dt><dd><p>
      As mentioned in <a class="xref" href="cha.boot.html#sec.boot.initrd" title="10.2. initramfs">Section 10.2, “<code class="systemitem">initramfs</code>”</a>, the boot process
      starts with a minimum set of drivers that can be used with most hardware
      configurations. <code class="systemitem">init</code> starts an initial hardware
      scanning process that determines the set of drivers suitable for your
      hardware configuration. These drivers are used to generate a custom
      <code class="systemitem">initramfs</code> that is needed to boot the system. If
      the modules are not needed for boot but for coldplug, the modules can be
      loaded with <code class="systemitem">systemd</code>; for more information, see
      <a class="xref" href="cha.systemd.html#sec.boot.systemd.advanced.kernel_modules" title="13.6.4. Loading Kernel Modules">Section 13.6.4, “Loading Kernel Modules”</a>.

     </p></dd><dt id="idm140310248339200"><span class="term ">Loading the Installation System</span></dt><dd><p>
      When the hardware is properly recognized, the appropriate drivers are
      loaded. The <code class="systemitem">udev</code> program creates
      the special device files and <code class="systemitem">init</code> starts the
      installation system with the YaST installer.
     </p></dd><dt id="idm140310248336064"><span class="term ">Starting YaST</span></dt><dd><p>
      Finally, <code class="systemitem">init</code> starts YaST, which starts
      package installation and system configuration.
     </p></dd></dl></div></div></div></div><div class="page-bottom"><div id="_bottom-navigation"><a class="nav-link" href="cha.uefi.html"><span class="next-icon">→</span><span class="nav-label"><span class="number">Chapter 11 </span>UEFI (Unified Extensible Firmware Interface)</span></a><a class="nav-link" href="part.boot.html"><span class="prev-icon">←</span><span class="nav-label"><span class="number">Part II </span>Booting a Linux System</span></a></div><div id="_share-print"><div class="online-contents share"><strong>Share this page: </strong><span class="share-buttons"><span id="_share-fb" class="bottom-button">Facebook</span><span class="spacer"> • </span><span id="_share-gp" class="bottom-button">Google+</span><span class="spacer"> • </span><span id="_share-tw" class="bottom-button">Twitter</span><span class="spacer"> • </span><span id="_share-mail" class="bottom-button">E-Mail</span></span></div><div class="print"><span id="_print-button" class="bottom-button">Print this page</span></div><div class="clearme"></div></div></div></div><div id="_inward"></div></div><div id="_footer-wrap"><div id="_footer"><p>©
        2018 
        SUSE</p><ul><li><a href="http://www.suse.com/company/careers/" target="_top">Careers</a></li><li><a href="http://www.suse.com/company/legal/" target="_top">Legal</a></li><li><a href="http://www.suse.com/company/" target="_top">About</a></li><li><a href="http://www.suse.com/ContactsOffices/contacts_offices.jsp" target="_top">Contact Us</a></li></ul></div></div></body></html>