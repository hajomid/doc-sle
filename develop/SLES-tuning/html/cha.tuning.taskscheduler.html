<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tuning the Task Scheduler | System Analysis and Tuning Guide | SUSE Linux Enterprise Server 15</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /><link rel="stylesheet" type="text/css" href="static/css/style.css" /><link rel="stylesheet" type="text/css" href="static/css/highlight.css" /><meta name="generator" content="DAPS 2.4.0 using SUSE XSL Stylesheets 2.0.8 (based on DocBook XSL Stylesheets 1.78.1) - chunked" /><meta name="product-name" content="SUSE Linux Enterprise Server" /><meta name="product-number" content="15" /><meta name="book-title" content="System Analysis and Tuning Guide" /><meta name="chapter-title" content="Chapter 13. Tuning the Task Scheduler" /><meta name="tracker-url" content="https://bugzilla.suse.com/enter_bug.cgi" /><meta name="tracker-type" content="bsc" /><meta name="tracker-bsc-assignee" content="fs@suse.com" /><meta name="tracker-bsc-component" content="Documentation" /><meta name="tracker-bsc-product" content="Beta SUSE Linux Enterprise Server 15" /><link rel="home" href="index.html" title="SUSE Linux Enterprise Server Documentation" /><link rel="up" href="part.tuning.kernel.html" title="Part V. Kernel Tuning" /><link rel="prev" href="cha.tuning.io.html" title="Chapter 12. Tuning I/O Performance" /><link rel="next" href="cha.tuning.memory.html" title="Chapter 14. Tuning the Memory Management Subsystem" /><script type="text/javascript">

var protocol = window.location.protocol.toLowerCase();
if ( protocol != 'file:' ) {
  var agent = navigator.userAgent.toLowerCase();
  var wanted = ( protocol == 'https:') ? 'https' : 'http';
  var file = 'fonts.css';
  document.write('<link rel="stylesheet" type="text/css" href="' + wanted + '://static.opensuse.org/fonts/'+ file +'"></link>');
}
else {
   document.write('<link rel="stylesheet" type="text/css" href="static/css/fonts-onlylocal.css"></link>');
}

</script><noscript><link rel="stylesheet" type="text/css" href="http://static.opensuse.org/fonts/fonts.css" /></noscript><script src="static/js/jquery-1.10.2.min.js" type="text/javascript"></script><script src="static/js/script.js" type="text/javascript"></script><script src="static/js/highlight.min.js" type="text/javascript"></script><script>

$(document).ready(function() {
  $('.verbatim-wrap.highlight').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
hljs.configure({
  useBR: false
});

</script></head><body class="draft offline js-off"><div id="_outer-wrap"><div id="_white-bg"><div id="_header"><div id="_logo"><img src="static/images/logo.png" alt="Logo" /></div><div class="crumbs"><a class="book-link" href="index.html" title="SUSE Linux Enterprise Server Documentation"><span class="book-icon">SUSE Linux Enterprise Server Documentation</span></a><span> › </span><a class="crumb" href="book.sle.tuning.html">System Analysis and Tuning Guide</a><span> › </span><a class="crumb" href="part.tuning.kernel.html">Kernel Tuning</a><span> › </span><a class="crumb" href="cha.tuning.taskscheduler.html">Tuning the Task Scheduler</a></div><div class="clearme"></div></div></div><div id="_toolbar-wrap"><div id="_toolbar"><div id="_toc-area" class="inactive"><a id="_toc-area-button" class="tool" title="Contents" accesskey="c" href="index.html"><span class="tool-spacer"><span class="toc-icon">Contents</span><span class="clearme"></span></span><span class="tool-label">Contents</span></a><div class="active-contents bubble-corner"></div><div class="active-contents bubble"><div class="bubble-container"><h6>System Analysis and Tuning Guide</h6><div id="_bubble-toc"><ol><li class="inactive"><a href="preface.tuning.html"><span class="number"> </span><span class="name">About This Guide</span></a></li><li class="inactive"><a href="part.tuning.basics.html"><span class="number">I </span><span class="name">Basics</span></a><ol><li class="inactive"><a href="cha.tuning.basics.html"><span class="number">1 </span><span class="name">General Notes on System Tuning</span></a></li></ol></li><li class="inactive"><a href="part.tuning.monitoring.html"><span class="number">II </span><span class="name">System Monitoring</span></a><ol><li class="inactive"><a href="cha.util.html"><span class="number">2 </span><span class="name">System Monitoring Utilities</span></a></li><li class="inactive"><a href="cha.tuning.logfiles.html"><span class="number">3 </span><span class="name">Analyzing and Managing System Log Files</span></a></li></ol></li><li class="inactive"><a href="part.tuning.kerneltrace.html"><span class="number">III </span><span class="name">Kernel Monitoring</span></a><ol><li class="inactive"><a href="cha.tuning.systemtap.html"><span class="number">4 </span><span class="name">SystemTap—Filtering and Analyzing System Data</span></a></li><li class="inactive"><a href="cha.tuning.kprobes.html"><span class="number">5 </span><span class="name">Kernel Probes</span></a></li><li class="inactive"><a href="cha.perf.html"><span class="number">6 </span><span class="name">Hardware-Based Performance Monitoring with Perf</span></a></li><li class="inactive"><a href="cha.tuning.oprofile.html"><span class="number">7 </span><span class="name">OProfile—System-Wide Profiler</span></a></li></ol></li><li class="inactive"><a href="part.tuning.resources.html"><span class="number">IV </span><span class="name">Resource Management</span></a><ol><li class="inactive"><a href="cha.tuning.resources.html"><span class="number">8 </span><span class="name">General System Resource Management</span></a></li><li class="inactive"><a href="cha.tuning.cgroups.html"><span class="number">9 </span><span class="name">Kernel Control Groups</span></a></li><li class="inactive"><a href="cha.tuning.numactl.html"><span class="number">10 </span><span class="name">Automatic Non-Uniform Memory Access (NUMA) Balancing</span></a></li><li class="inactive"><a href="cha.tuning.power.html"><span class="number">11 </span><span class="name">Power Management</span></a></li></ol></li><li class="inactive"><a href="part.tuning.kernel.html"><span class="number">V </span><span class="name">Kernel Tuning</span></a><ol><li class="inactive"><a href="cha.tuning.io.html"><span class="number">12 </span><span class="name">Tuning I/O Performance</span></a></li><li class="inactive"><a href="cha.tuning.taskscheduler.html"><span class="number">13 </span><span class="name">Tuning the Task Scheduler</span></a></li><li class="inactive"><a href="cha.tuning.memory.html"><span class="number">14 </span><span class="name">Tuning the Memory Management Subsystem</span></a></li><li class="inactive"><a href="cha.tuning.network.html"><span class="number">15 </span><span class="name">Tuning the Network</span></a></li></ol></li><li class="inactive"><a href="part.tuning.dumps.html"><span class="number">VI </span><span class="name">Handling System Dumps</span></a><ol><li class="inactive"><a href="cha.tuning.tracing.html"><span class="number">16 </span><span class="name">Tracing Tools</span></a></li><li class="inactive"><a href="cha.tuning.kexec.html"><span class="number">17 </span><span class="name">Kexec and Kdump</span></a></li></ol></li><li class="inactive"><a href="part.tuning.ptp.html"><span class="number">VII </span><span class="name">Synchronized Clocks with Precision Time Protocol</span></a><ol><li class="inactive"><a href="cha.tuning.ptp.html"><span class="number">18 </span><span class="name">Precision Time Protocol</span></a></li></ol></li><li class="inactive"><a href="bk07apa.html"><span class="number">A </span><span class="name">GNU Licenses</span></a></li></ol></div><div class="clearme"></div></div></div></div><div id="_nav-area" class="inactive"><div class="tool"><span class="nav-inner"><span class="tool-label">Navigation</span><a accesskey="p" class="tool-spacer" title="Chapter 12. Tuning I/O Performance" href="cha.tuning.io.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Chapter 14. Tuning the Memory Management Subsystem" href="cha.tuning.memory.html"><span class="next-icon">→</span></a></span></div></div></div></div><div id="_fixed-header-wrap" class="inactive"><div id="_fixed-header"><div class="crumbs"><a class="book-link" href="index.html" title="SUSE Linux Enterprise Server Documentation"><span class="book-icon">SUSE Linux Enterprise Server Documentation</span></a><span> › </span><a class="crumb" href="book.sle.tuning.html">System Analysis and Tuning Guide</a><span> › </span><a class="crumb" href="part.tuning.kernel.html">Kernel Tuning</a><span> › </span><a class="crumb" href="cha.tuning.taskscheduler.html">Tuning the Task Scheduler</a></div><div class="buttons"><a class="top-button button" href="#">Top</a><div class="button"><a accesskey="p" class="tool-spacer" title="Chapter 12. Tuning I/O Performance" href="cha.tuning.io.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Chapter 14. Tuning the Memory Management Subsystem" href="cha.tuning.memory.html"><span class="next-icon">→</span></a></div><div class="clearme"></div></div><div class="clearme"></div></div></div><div id="_content" class="draft "><div class="documentation"><div class="chapter " id="cha.tuning.taskscheduler"><div class="titlepage"><div><div class="version-info">Applies to  <span class="productname"><span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span></span> <span class="productnumber"><span class="productnumber"><span class="phrase">15</span></span></span></div><div><h2 class="title"><span class="number">13 </span><span class="name">Tuning the Task Scheduler</span> </h2><div class="doc-status"><ul><li><span class="ds-label">Filename: </span>tuning_taskscheduler.xml</li><li><span class="ds-label">ID: </span>cha.tuning.taskscheduler</li></ul></div></div></div></div><div class="line"><div class="toc"><dl><dt><span class="sect1"><a href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.intro"><span class="number">13.1 </span><span class="name">Introduction</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.policy.class"><span class="number">13.2 </span><span class="name">Process Classification</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs"><span class="number">13.3 </span><span class="name">Completely Fair Scheduler</span></a></span></dt><dt><span class="sect1"><a href="cha.tuning.taskscheduler.html#cha.tuning.taskscheduler.moreinfo"><span class="number">13.4 </span><span class="name">For More Information</span></a></span></dt></dl></div></div><p>
  Modern operating systems, such as <span class="productname"><span class="phrase">SUSE® Linux Enterprise Server</span></span>, normally run many
  tasks at the same time. For example, you can be searching in a
  text file while receiving an e-mail and copying a big file to an external
  hard disk. These simple tasks require many additional processes to be run
  by the system. To provide each task with its required system resources,
  the Linux kernel needs a tool to distribute available system resources to
  individual tasks. And this is exactly what the <span class="emphasis"><em>task
  scheduler</em></span> does.
 </p><p>
  The following sections explain the most important terms related to a
  process scheduling. They also introduce information about the task
  scheduler policy, scheduling algorithm, description of the task scheduler
  used by <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span>, and references to other sources of relevant
  information.
 </p><div class="sect1 " id="sec.tuning.taskscheduler.intro"><div class="titlepage"><div><div><h2 class="title" id="sec.tuning.taskscheduler.intro"><span class="number">13.1 </span><span class="name">Introduction</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.intro">#</a></h2></div></div></div><p>
   The Linux kernel controls the way that tasks (or processes) are managed
   on the system. The task scheduler, sometimes called <span class="emphasis"><em>process
   scheduler</em></span>, is the part of the kernel that decides which task
   to run next. It is responsible for best using system resources to
   guarantee that multiple tasks are being executed simultaneously. This
   makes it a core component of any multitasking operating system.
  </p><div class="sect2 " id="sec.tuning.taskscheduler.intro.preemption"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.intro.preemption"><span class="number">13.1.1 </span><span class="name">Preemption</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.intro.preemption">#</a></h3></div></div></div><p>
    The theory behind task scheduling is very simple. If there are runnable
    processes in a system, at least one process must always be running. If
    there are more runnable processes than processors in a system, not all
    the processes can be running all the time.
   </p><p>
    Therefore, some processes need to be stopped temporarily, or
    <span class="emphasis"><em>suspended</em></span>, so that others can be running again. The
    scheduler decides what process in the queue will run next.
   </p><p>
    As already mentioned, Linux, like all other Unix variants, is a
    <span class="emphasis"><em>multitasking</em></span> operating system. That means that
    several tasks can be running at the same time. Linux provides a so
    called <span class="emphasis"><em>preemptive</em></span> multitasking, where the scheduler
    decides when a process is suspended. This forced suspension is called
    <span class="emphasis"><em>preemption</em></span>. All Unix flavors have been providing
    preemptive multitasking since the beginning.
   </p></div><div class="sect2 " id="sec.tuning.taskscheduler.intro.timeslice"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.intro.timeslice"><span class="number">13.1.2 </span><span class="name">Timeslice</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.intro.timeslice">#</a></h3></div></div></div><p>
    The time period for which a process will be running before it is
    <span class="emphasis"><em>preempted</em></span> is defined in advance. It is called a
    <span class="emphasis"><em>timeslice</em></span> of a process and represents the amount of
    processor time that is provided to each process. By assigning
    timeslices, the scheduler makes global decisions for the running system,
    and prevents individual processes from dominating over the processor
    resources.
    
   </p></div><div class="sect2 " id="sec.tuning.taskscheduler.intro.priority"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.intro.priority"><span class="number">13.1.3 </span><span class="name">Process Priority</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.intro.priority">#</a></h3></div></div></div><p>
    The scheduler evaluates processes based on their priority. To calculate
    the current priority of a process, the task scheduler uses complex
    algorithms. As a result, each process is given a value according to
    which it is <span class="quote">“<span class="quote">allowed</span>”</span> to run on a processor.
   </p></div></div><div class="sect1 " id="sec.tuning.taskscheduler.policy.class"><div class="titlepage"><div><div><h2 class="title" id="sec.tuning.taskscheduler.policy.class"><span class="number">13.2 </span><span class="name">Process Classification</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.policy.class">#</a></h2></div></div></div><p>
   Processes are usually classified according to their purpose and behavior.
   Although the borderline is not always clearly distinct, generally two
   criteria are used to sort them. These criteria are independent and do not
   exclude each other.
  </p><p>
   One approach is to classify a process either
   <span class="emphasis"><em>I/O-bound</em></span> or <span class="emphasis"><em>processor-bound</em></span>.
  </p><div class="variablelist "><dl class="variablelist"><dt id="idm139783837988544"><span class="term ">I/O-bound</span></dt><dd><p>
      I/O stands for Input/Output devices, such as keyboards, mice, or
      optical and hard disks. <span class="emphasis"><em>I/O-bound processes</em></span> spend
      the majority of time submitting and waiting for requests. They are run
      very frequently, but for short time intervals, not to block other
      processes waiting for I/O requests.
     </p></dd><dt id="idm139783837986032"><span class="term ">processor-bound</span></dt><dd><p>
      On the other hand, <span class="emphasis"><em>processor-bound</em></span> tasks use
      their time to execute a code, and usually run until they are preempted
      by the scheduler. They do not block processes waiting for I/O
      requests, and, therefore, can be run less frequently but for longer
      time intervals.
     </p></dd></dl></div><p>
   Another approach is to divide processes by type into
   <span class="emphasis"><em>interactive</em></span>, <span class="emphasis"><em>batch</em></span>, and
   <span class="emphasis"><em>real-time</em></span> processes.
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     <span class="emphasis"><em>Interactive</em></span> processes spend a lot of time waiting
     for I/O requests, such as keyboard or mouse operations. The scheduler
     must wake up such processes quickly on user request, or the user will
     find the environment unresponsive. The typical delay is approximately
     100 ms. Office applications, text editors or image manipulation
     programs represent typical interactive processes.
    </p></li><li class="listitem "><p>
     <span class="emphasis"><em>Batch</em></span> processes often run in the background and do
     not need to be responsive. They usually receive lower priority from the
     scheduler. Multimedia converters, database search engines, or log files
     analyzers are typical examples of batch processes.
    </p></li><li class="listitem "><p>
     <span class="emphasis"><em>Real-time</em></span> processes must never be blocked by
     low-priority processes, and the scheduler guarantees a short response
     time to them. Applications for editing multimedia content are a good
     example here.
    </p></li></ul></div></div><div class="sect1 " id="sec.tuning.taskscheduler.cfs"><div class="titlepage"><div><div><h2 class="title" id="sec.tuning.taskscheduler.cfs"><span class="number">13.3 </span><span class="name">Completely Fair Scheduler</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs">#</a></h2></div></div></div><p>
   Since the Linux kernel version 2.6.23, a new approach has been taken to
   the scheduling of runnable processes. Completely Fair Scheduler (CFS)
   became the default Linux kernel scheduler. Since then, important changes
   and improvements have been made. The information in this chapter applies
   to <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> with kernel version 2.6.32 and higher (including 3.x
   kernels). The scheduler environment was divided into several parts, and
   three main new features were introduced:
  </p><div class="variablelist "><dl class="variablelist"><dt id="idm139783837972112"><span class="term ">Modular Scheduler Core</span></dt><dd><p>
      The core of the scheduler was enhanced with <span class="emphasis"><em>scheduling
      classes</em></span>. These classes are modular and represent scheduling
      policies.
     </p></dd><dt id="idm139783837969760"><span class="term ">Completely Fair Scheduler</span></dt><dd><p>
      Introduced in kernel 2.6.23 and extended in 2.6.24, CFS tries to
      assure that each process obtains its <span class="quote">“<span class="quote">fair</span>”</span> share of the
      processor time.
     </p></dd><dt id="idm139783837967376"><span class="term ">Group Scheduling</span></dt><dd><p>
      For example, if you split processes into groups according to which
      user is running them, CFS tries to provide each of these groups with
      the same amount of processor time.
     </p></dd></dl></div><p>
   As a result, CFS brings optimized scheduling for both servers and
   desktops.
  </p><div class="sect2 " id="sec.tuning.taskscheduler.cfs.howitworks"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.cfs.howitworks"><span class="number">13.3.1 </span><span class="name">How CFS Works</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.howitworks">#</a></h3></div></div></div><p>
    CFS tries to guarantee a fair approach to each runnable task. To find
    the most balanced way of task scheduling, it uses the concept of
    <span class="emphasis"><em>red-black tree</em></span>. A red-black tree is a type of
    self-balancing data search tree which provides inserting and removing
    entries in a reasonable way so that it remains well balanced. For more
    information, see the wiki pages of
    <a class="link" href="http://en.wikipedia.org/wiki/Red_black_tree" target="_blank">Red-black
    tree</a>.
   </p><p>
    When CFS schedules a task it accumulates <span class="quote">“<span class="quote">virtual
    runtime</span>”</span> or <span class="emphasis"><em>vruntime</em></span>. The next task picked
    to run is always the task with the minimum accumulated vruntime so
    far. By balancing the red-black tree when tasks are inserted into the
    <span class="emphasis"><em>run queue</em></span> (a planned time line of processes to be
    executed next), the task with the minimum vruntime is always the first
    entry in the red-black tree.
   </p><p>
    The amount of vruntime a task accrues is related to its priority.
    High priority tasks gain vruntime at a slower rate than low priority
    tasks, which results in high priority tasks being picked to run on the
    processor more often.
   </p></div><div class="sect2 " id="sec.tuning.taskscheduler.cfs.grouping"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.cfs.grouping"><span class="number">13.3.2 </span><span class="name">Grouping Processes</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.grouping">#</a></h3></div></div></div><p>
    Since the Linux kernel version 2.6.24, CFS can be tuned to be fair
    to groups rather than to tasks only. Runnable tasks are then grouped
    to form entities, and CFS tries to be fair to these entities instead
    of individual runnable tasks. The scheduler also tries to be fair to
    individual tasks within these entities.
   </p><p>
    The kernel scheduler lets you group runnable tasks using control
    groups. For more information, see <a class="xref" href="cha.tuning.cgroups.html" title="Chapter 9. Kernel Control Groups">Chapter 9, <em>Kernel Control Groups</em></a>.
   </p></div><div class="sect2 " id="sec.tuning.taskscheduler.cfs.kernelconfig"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.cfs.kernelconfig"><span class="number">13.3.3 </span><span class="name">Kernel Configuration Options</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.kernelconfig">#</a></h3></div></div></div><p>
    Basic aspects of the task scheduler behavior can be set through the
    kernel configuration options. Setting these options is part of the
    kernel compilation process. Because kernel compilation process is a
    complex task and out of this document's scope, refer to relevant source
    of information.
   </p><div id="idm139783837953344" class="admonition warning normal"><img class="symbol" alt="Warning" title="Warning" src="static/images/icon-warning.png" /><h6>Warning: Kernel Compilation</h6><p>
     If you run <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> on a kernel that was not shipped with it,
     for example on a self-compiled kernel, you lose the entire support
     entitlement.
    </p></div></div><div class="sect2 " id="sec.tuning.taskscheduler.cfs.terms"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.cfs.terms"><span class="number">13.3.4 </span><span class="name">Terminology</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.terms">#</a></h3></div></div></div><p>
    Documents regarding task scheduling policy often use several technical
    terms which you need to know to understand the information correctly.
    Here are some:
   </p><div class="variablelist "><dl class="variablelist"><dt id="idm139783837948496"><span class="term ">Latency</span></dt><dd><p>
       Delay between the time a process is scheduled to run and the actual
       process execution.
      </p></dd><dt id="idm139783837946608"><span class="term ">Granularity</span></dt><dd><p>
       The relation between granularity and latency can be expressed by the
       following equation:
      </p><div class="verbatim-wrap"><pre class="screen">gran = ( lat / rtasks ) - ( lat / rtasks / rtasks )</pre></div><p>
       where <span class="emphasis"><em>gran</em></span> stands for granularity,
       <span class="emphasis"><em>lat</em></span> stand for latency, and
       <span class="emphasis"><em>rtasks</em></span> is the number of running tasks.
      </p></dd></dl></div><div class="sect3 " id="kernel.tasksched.policies"><div class="titlepage"><div><div><h4 class="title" id="kernel.tasksched.policies"><span class="number">13.3.4.1 </span><span class="name">Scheduling Policies</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#kernel.tasksched.policies">#</a></h4></div></div></div><p>
     The Linux kernel supports the following scheduling policies:
    </p><div class="variablelist "><dl class="variablelist"><dt id="idm139783837940256"><span class="term ">SCHED_FIFO</span></dt><dd><p>
        Scheduling policy designed for special time-critical applications.
        It uses the First In-First Out scheduling algorithm.
       </p></dd><dt id="idm139783837938336"><span class="term ">SCHED_BATCH</span></dt><dd><p>
        Scheduling policy designed for CPU-intensive tasks.
       </p></dd><dt id="idm139783837936496"><span class="term ">SCHED_IDLE</span></dt><dd><p>
        Scheduling policy intended for <span class="emphasis"><em>very</em></span> low
        prioritized tasks.
       </p></dd><dt id="idm139783837934256"><span class="term ">SCHED_OTHER</span></dt><dd><p>
        Default Linux time-sharing scheduling policy used by the majority of
        processes.
       </p></dd><dt id="idm139783837932368"><span class="term ">SCHED_RR</span></dt><dd><p>
        Similar to <code class="systemitem">SCHED_FIFO</code>, but uses the Round
        Robin scheduling algorithm.
       </p></dd></dl></div></div></div><div class="sect2 " id="sec.tuning.taskscheduler.cfs.chrt"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.cfs.chrt"><span class="number">13.3.5 </span><span class="name">Changing Real-time Attributes of Processes with <code class="command">chrt</code></span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.chrt">#</a></h3></div></div></div><p>
    The <code class="command">chrt</code> command sets or retrieves the real-time
    scheduling attributes of a running process, or runs a command with the
    specified attributes. You can get or retrieve both the scheduling policy
    and priority of a process.
   </p><p>
    In the following examples, a process whose PID is 16244 is used.
   </p><p>
    To <span class="emphasis"><em>retrieve</em></span> the real-time attributes of an existing
    task:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>chrt -p 16244
pid 16244's current scheduling policy: SCHED_OTHER
pid 16244's current scheduling priority: 0</pre></div><p>
    Before setting a new scheduling policy on the process, you need to find
    out the minimum and maximum valid priorities for each scheduling
    algorithm:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>chrt -m
SCHED_SCHED_OTHER min/max priority : 0/0
SCHED_SCHED_FIFO min/max priority : 1/99
SCHED_SCHED_RR min/max priority : 1/99
SCHED_SCHED_BATCH min/max priority : 0/0
SCHED_SCHED_IDLE min/max priority : 0/0</pre></div><p>
    In the above example, SCHED_OTHER, SCHED_BATCH, SCHED_IDLE polices only
    allow for priority 0, while that of SCHED_FIFO and SCHED_RR can range
    from 1 to 99.
   </p><p>
    To set SCHED_BATCH scheduling policy:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>chrt -b -p 0 16244
pid 16244's current scheduling policy: SCHED_BATCH
pid 16244's current scheduling priority: 0</pre></div><p>
    For more information on <code class="command">chrt</code>, see its man page
    (<code class="command">man 1 chrt</code>).
   </p></div><div class="sect2 " id="sec.tuning.taskscheduler.cfs.tuning"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.cfs.tuning"><span class="number">13.3.6 </span><span class="name">Runtime Tuning with <code class="command">sysctl</code></span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.tuning">#</a></h3></div></div></div><p>
    The <code class="command">sysctl</code> interface for examining and changing
    kernel parameters at runtime introduces important variables by means of
    which you can change the default behavior of the task scheduler. The
    syntax of the <code class="command">sysctl</code> is simple, and all the following
    commands must be entered on the command line as <code class="systemitem">root</code>.
   </p><p>
    To read a value from a kernel variable, enter
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">sysctl</code> <em class="replaceable ">VARIABLE</em></pre></div><p>
    To assign a value, enter
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">sysctl</code> <em class="replaceable ">VARIABLE</em>=<em class="replaceable ">VALUE</em></pre></div><p>
    To get a list of all scheduler related <code class="command">sysctl</code>
    variables, enter
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code><code class="command">sysctl</code> <code class="option">-A</code> | <code class="command">grep</code> <em class="replaceable ">"sched"</em> | <code class="command">grep</code> <code class="option">-v</code><em class="replaceable ">"domain"</em></pre></div><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>sysctl -A | grep "sched" | grep -v "domain"
kernel.sched_cfs_bandwidth_slice_us = 5000
kernel.sched_child_runs_first = 0
kernel.sched_compat_yield = 0
kernel.sched_latency_ns = 24000000
kernel.sched_migration_cost_ns = 500000
kernel.sched_min_granularity_ns = 8000000
kernel.sched_nr_migrate = 32
kernel.sched_rr_timeslice_ms = 25
kernel.sched_rt_period_us = 1000000
kernel.sched_rt_runtime_us = 950000
kernel.sched_schedstats = 0
kernel.sched_shares_window_ns = 10000000
kernel.sched_time_avg_ms = 1000
kernel.sched_tunable_scaling = 1
kernel.sched_wakeup_granularity_ns = 10000000</pre></div><p>
    Note that variables ending with <span class="quote">“<span class="quote">_ns</span>”</span> and
    <span class="quote">“<span class="quote">_us</span>”</span> accept values in nanoseconds and microseconds,
    respectively.
   </p><p>
    A list of the most important task scheduler <code class="command">sysctl</code>
    tuning variables (located at <code class="filename">/proc/sys/kernel/</code>)
    with a short description follows:
   </p><div class="variablelist "><dl class="variablelist"><dt id="idm139783837901248"><span class="term "><code class="systemitem">sched_cfs_bandwidth_slice_us</code>
     </span></dt><dd><p>
       When CFS bandwidth control is in use, this parameter controls
       the amount of run-time (bandwidth) transferred to a run queue from the
       task's control group bandwidth pool. Small values allow the global
       bandwidth to be shared in a fine-grained manner among tasks, larger
       values reduce transfer overhead. See
       <a class="link" href="https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt" target="_blank">https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt</a>.
      </p></dd><dt id="idm139783837898208"><span class="term "><code class="systemitem">sched_child_runs_first</code>
     </span></dt><dd><p>
       A freshly forked child runs before the parent continues execution.
       Setting this parameter to <code class="literal">1</code> is beneficial for an
       application in which the child performs an execution after fork. For
       example <code class="command">make</code>
       <code class="option">-j<em class="replaceable ">&lt;NO_CPUS&gt;</em></code>
       performs better when sched_child_runs_first is turned off. The
       default value is <code class="literal">0</code>.
      </p></dd><dt id="idm139783837893776"><span class="term "><code class="systemitem">sched_compat_yield</code>
     </span></dt><dd><p>
       Enables the aggressive CPU yielding behavior of the old
       <span class="emphasis"><em>O(1)</em></span> scheduler by moving the relinquishing task to
       the end of the runnable queue (right-most position in the red-black
       tree). Applications that depend on the <code class="option">sched_yield(2)</code>
       syscall behavior may see performance improvements by giving other
       processes a chance to run when there are highly contended resources
       (such as locks). On the other hand, given that this call occurs in
       context switching, misusing the call can hurt the workload. Only use it
       when you see a drop in performance. The default value is
       <code class="literal">0</code>.
      </p></dd><dt id="idm139783837889792"><span class="term "><code class="systemitem">sched_migration_cost_ns</code>
     </span></dt><dd><p>
       Amount of time after the last execution that a task is considered to
       be <span class="quote">“<span class="quote">cache hot</span>”</span> in migration decisions. A
       <span class="quote">“<span class="quote">hot</span>”</span> task is less likely to be migrated to another CPU,
       so increasing this variable reduces task migrations. The default value is
       <code class="literal">500000</code> (ns).
      </p><p>
       If the CPU idle time is higher than expected when there are runnable
       processes, try reducing this value. If tasks bounce between CPUs or
       nodes too often, try increasing it.
      </p></dd><dt id="idm139783837885520"><span class="term "><code class="systemitem">sched_latency_ns</code>
     </span></dt><dd><p>
       Targeted preemption latency for CPU bound tasks. Increasing this
       variable increases a CPU bound task's timeslice. A task's timeslice
       is its weighted fair share of the scheduling period:
      </p><p>
       timeslice = scheduling period * (task's weight/total weight of tasks
       in the run queue)
      </p><p>
       The task's weight depends on the task's nice level and the scheduling
       policy. Minimum task weight for a SCHED_OTHER task is 15,
       corresponding to nice 19. The maximum task weight is 88761,
       corresponding to nice -20.
      </p><p>
       Timeslices become smaller as the load increases. When the number of
       runnable tasks exceeds
       <code class="systemitem">sched_latency_ns</code>/<code class="systemitem">sched_min_granularity_ns</code>,
       the slice becomes number_of_running_tasks *
       <code class="systemitem">sched_min_granularity_ns</code>. Prior to that, the
       slice is equal to <code class="systemitem">sched_latency_ns</code>.
      </p><p>
       This value also specifies the maximum amount of time during which a
       sleeping task is considered to be running for entitlement
       calculations. Increasing this variable increases the amount of time a
       waking task may consume before being preempted, thus increasing
       scheduler latency for CPU bound tasks. The default value is
       <code class="literal">6000000</code> (ns).
      </p></dd><dt id="idm139783837878320"><span class="term "><code class="systemitem">sched_min_granularity_ns</code>
     </span></dt><dd><p>
       Minimal preemption granularity for CPU bound tasks. See
       <code class="systemitem">sched_latency_ns</code> for details. The default
       value is <code class="literal">4000000</code> (ns).
      </p></dd><dt id="idm139783837875248"><span class="term "><code class="systemitem">sched_wakeup_granularity_ns</code>
     </span></dt><dd><p>
       The wake-up preemption granularity. Increasing this variable reduces
       wake-up preemption, reducing disturbance of compute bound tasks.
       Lowering it improves wake-up latency and throughput for latency
       critical tasks, particularly when a short duty cycle load component
       must compete with CPU bound components. The default value is
       <code class="literal">2500000</code> (ns).
      </p><div id="idm139783837872672" class="admonition warning normal"><img class="symbol" alt="Warning" title="Warning" src="static/images/icon-warning.png" /><h6>Warning: Setting the Right Wake-up Granularity Value</h6><p>
        Settings larger than half of
        <code class="systemitem">sched_latency_ns</code> will result in no wake-up
        preemption. Short duty cycle tasks will be unable to compete with
        CPU hogs effectively.
       </p></div></dd><dt id="idm139783837870368"><span class="term "><code class="systemitem">sched_rr_timeslice_ms</code>
     </span></dt><dd><p>
       Quantum that SCHED_RR tasks are allowed to run before they are
       preempted and put to the end of the task list.
      </p></dd><dt id="idm139783837868176"><span class="term "><code class="systemitem">sched_rt_period_us</code>
     </span></dt><dd><p>
       Period over which real-time task bandwidth enforcement is measured.
       The default value is <code class="literal">1000000</code> (µs).
      </p></dd><dt id="idm139783837865552"><span class="term "><code class="systemitem">sched_rt_runtime_us</code>
     </span></dt><dd><p>
       Quantum allocated to real-time tasks during sched_rt_period_us.
       Setting to -1 disables RT bandwidth enforcement. By default, RT tasks
       may consume 95%CPU/sec, thus leaving 5%CPU/sec or 0.05s to be used by
       SCHED_OTHER tasks. The default value is <code class="literal">950000</code>
       (µs).
      </p></dd><dt id="idm139783837862768"><span class="term "><code class="systemitem">sched_nr_migrate</code>
     </span></dt><dd><p>
       Controls how many tasks can be migrated across processors for
       load-balancing purposes. Because balancing iterates the runqueue
       with interrupts disabled (softirq), it can incur in irq-latency
       penalties for real-time tasks.  Therefore increasing this value
       may give a performance boost to large SCHED_OTHER threads at the
       expense of increased irq-latencies for real-time tasks. The default
       value is <code class="literal">32</code>.
      </p></dd><dt id="idm139783837859808"><span class="term "><code class="systemitem">sched_time_avg_ms</code>
     </span></dt><dd><p>
      This parameter sets the period over which the time spent running
      real-time tasks is averaged. That average assists CFS in making
      load-balancing decisions and gives an indication of how busy a CPU is
      with high-priority real-time tasks.
      </p><p>
      The optimal setting for this parameter is highly workload
      dependent and depends, among other things, on how frequently
      real-time tasks are running and for how long.
      </p></dd></dl></div></div><div class="sect2 " id="sec.tuning.taskscheduler.cfs.debug"><div class="titlepage"><div><div><h3 class="title" id="sec.tuning.taskscheduler.cfs.debug"><span class="number">13.3.7 </span><span class="name">Debugging Interface and Scheduler Statistics</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.debug">#</a></h3></div></div></div><p>
    CFS comes with a new improved debugging interface, and provides runtime
    statistics information. Relevant files were added to the
    <code class="filename">/proc</code> file system, which can be examined simply
    with the <code class="command">cat</code> or <code class="command">less</code> command. A
    list of the related <code class="filename">/proc</code> files follows with their
    short description:
   </p><div class="variablelist "><dl class="variablelist"><dt id="idm139783837852608"><span class="term "><code class="filename">/proc/sched_debug</code>
     </span></dt><dd><p>
       Contains the current values of all tunable variables (see <a class="xref" href="cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.tuning" title="13.3.6. Runtime Tuning with sysctl">Section 13.3.6, “Runtime Tuning with <code class="command">sysctl</code>”</a>) that affect the task
       scheduler behavior, CFS statistics, and information about the run queues
       (CFS, RT and deadline) on all available processors.  A summary of the
       task running on each processor is also shown, with the task name and
       PID, along with scheduler specific statistics. The first
       being <code class="option">tree-key</code> column, it indicates the task's virtual
       runtime, and its name comes from the kernel sorting all runnable tasks
       by this key in a red-black tree. The <code class="option">switches</code> column
       indicates the total number of switches (involuntary or not), and
       naturally the <code class="option">prio</code> refers to the process priority. The
       <code class="option">wait-time</code> value indicates the amount of time the task
       waited to be scheduled. Finally both <code class="option">sum-exec</code> and
       <code class="option">sum-sleep</code> account for the total amount of time (in
       nanoseconds) the task was running on the processor or asleep,
       respectively.
      </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>cat /proc/sched_debug
Sched Debug Version: v0.11, 4.4.21-64-default #1
ktime                                   : 23533900.395978
sched_clk                               : 23543587.726648
cpu_clk                                 : 23533900.396165
jiffies                                 : 4300775771
sched_clock_stable                      : 0

sysctl_sched
  .sysctl_sched_latency                    : 6.000000
  .sysctl_sched_min_granularity            : 2.000000
  .sysctl_sched_wakeup_granularity         : 2.500000
  .sysctl_sched_child_runs_first           : 0
  .sysctl_sched_features                   : 154871
  .sysctl_sched_tunable_scaling            : 1 (logaritmic)

cpu#0, 2666.762 MHz
  .nr_running                    : 1
  .load                          : 1024
  .nr_switches                   : 1918946
[...]

cfs_rq[0]:/
  .exec_clock                    : 170176.383770
  .MIN_vruntime                  : 0.000001
  .min_vruntime                  : 347375.854324
  .max_vruntime                  : 0.000001
[...]

rt_rq[0]:/
  .rt_nr_running                 : 0
  .rt_throttled                  : 0
  .rt_time                       : 0.000000
  .rt_runtime                    : 950.000000

dl_rq[0]:
  .dl_nr_running                 : 0

  task   PID         tree-key  switches  prio     wait-time        [...]
------------------------------------------------------------------------
R  cc1 63477     98876.717832       197   120      0.000000         ...</pre></div></dd><dt id="idm139783837843968"><span class="term "><code class="filename">/proc/schedstat</code>
     </span></dt><dd><p>
       Displays statistics relevant to the current run queue. Also
       domain-specific statistics for SMP systems are displayed for all
       connected processors. Because the output format is not user-friendly,
       read the contents of
       <code class="filename">/usr/src/linux/Documentation/scheduler/sched-stats.txt</code>
       for more information.
      </p></dd><dt id="idm139783837841152"><span class="term "><code class="filename">/proc/<em class="replaceable ">PID</em>/sched</code>
     </span></dt><dd><p>
       Displays scheduling information on the process with id
       <em class="replaceable ">PID</em>.
      </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>cat /proc/$(pidof gdm)/sched
gdm (744, #threads: 3)
-------------------------------------------------------------------
se.exec_start                                :          8888.758381
se.vruntime                                  :          6062.853815
se.sum_exec_runtime                          :             7.836043
se.statistics.wait_start                     :             0.000000
se.statistics.sleep_start                    :          8888.758381
se.statistics.block_start                    :             0.000000
se.statistics.sleep_max                      :          1965.987638
[...]
se.avg.decay_count                           :                 8477
policy                                       :                    0
prio                                         :                  120
clock-delta                                  :                  128
mm-&gt;numa_scan_seq                            :                    0
numa_migrations, 0
numa_faults_memory, 0, 0, 1, 0, -1
numa_faults_memory, 1, 0, 0, 0, -1</pre></div></dd></dl></div></div></div><div class="sect1 " id="cha.tuning.taskscheduler.moreinfo"><div class="titlepage"><div><div><h2 class="title" id="cha.tuning.taskscheduler.moreinfo"><span class="number">13.4 </span><span class="name">For More Information</span> <a title="Permalink" class="permalink" href="cha.tuning.taskscheduler.html#cha.tuning.taskscheduler.moreinfo">#</a></h2></div></div></div><p>
   To get a compact knowledge about Linux kernel task scheduling, you need
   to explore several information sources. Here are some:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     For task scheduler System Calls description, see the relevant manual
     page (for example <code class="command">man 2 sched_setaffinity</code>).
    </p></li><li class="listitem "><p>
     General information on scheduling is described in
     <a class="link" href="http://en.wikipedia.org/wiki/Scheduling_(computing)" target="_blank">Scheduling</a>
     wiki page.
    </p></li><li class="listitem "><p>
     A useful lecture on Linux scheduler policy and algorithm is available
     in
     <a class="link" href="http://www.inf.fu-berlin.de/lehre/SS01/OS/Lectures/Lecture08.pdf" target="_blank">http://www.inf.fu-berlin.de/lehre/SS01/OS/Lectures/Lecture08.pdf</a>.
    </p></li><li class="listitem "><p>
     A good overview of Linux process scheduling is given in
     <em class="citetitle ">Linux Kernel Development</em> by Robert Love
     (ISBN-10: 0-672-32512-8). See
     <a class="link" href="http://www.informit.com/articles/article.aspx?p=101760" target="_blank">http://www.informit.com/articles/article.aspx?p=101760</a>.
    </p></li><li class="listitem "><p>
     A very comprehensive overview of the Linux kernel internals is given in
     <em class="citetitle ">Understanding the Linux Kernel</em> by Daniel P.
     Bovet and Marco Cesati (ISBN 978-0-596-00565-8).
    </p></li><li class="listitem "><p>
     Technical information about task scheduler is covered in files under
     <code class="filename">/usr/src/linux/Documentation/scheduler</code>.
    </p></li></ul></div></div></div></div><div class="page-bottom"><div id="_bottom-navigation"><a class="nav-link" href="cha.tuning.memory.html"><span class="next-icon">→</span><span class="nav-label"><span class="number">Chapter 14 </span>Tuning the Memory Management Subsystem</span></a><a class="nav-link" href="cha.tuning.io.html"><span class="prev-icon">←</span><span class="nav-label"><span class="number">Chapter 12 </span>Tuning I/O Performance</span></a></div><div id="_share-print"><div class="online-contents share"><strong>Share this page: </strong><span class="share-buttons"><span id="_share-fb" class="bottom-button">Facebook</span><span class="spacer"> • </span><span id="_share-gp" class="bottom-button">Google+</span><span class="spacer"> • </span><span id="_share-tw" class="bottom-button">Twitter</span><span class="spacer"> • </span><span id="_share-mail" class="bottom-button">E-Mail</span></span></div><div class="print"><span id="_print-button" class="bottom-button">Print this page</span></div><div class="clearme"></div></div></div></div><div id="_inward"></div></div><div id="_footer-wrap"><div id="_footer"><p>©
        2018 
        SUSE</p><ul><li><a href="http://www.suse.com/company/careers/" target="_top">Careers</a></li><li><a href="http://www.suse.com/company/legal/" target="_top">Legal</a></li><li><a href="http://www.suse.com/company/" target="_top">About</a></li><li><a href="http://www.suse.com/ContactsOffices/contacts_offices.jsp" target="_top">Contact Us</a></li></ul></div></div></body></html>